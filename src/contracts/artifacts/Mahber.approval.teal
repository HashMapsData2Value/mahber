#pragma version 10

// This TEAL was generated by TEALScript v0.79.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// createApplication()void
abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts/mahber.algo.ts:46
	// this.denomination.value = 1000 * 1000000
	byte 0x64656e6f6d696e6174696f6e // "denomination"
	int 1000000000
	app_global_put

	// contracts/mahber.algo.ts:47
	// this.asaId.value = 0
	byte 0x6173614964 // "asaId"
	int 0
	app_global_put

	// contracts/mahber.algo.ts:48
	// this.pkIndex.value = 0
	byte 0x706b496e646578 // "pkIndex"
	int 0
	app_global_put
	retsub

// dummyOpUp(uint64)uint64
abi_route_dummyOpUp:
	// The ABI return prefix
	byte 0x151f7c75

	// i: uint64
	txna ApplicationArgs 1
	btoi

	// execute dummyOpUp(uint64)uint64
	callsub dummyOpUp
	itob
	concat
	log
	int 1
	return

// dummyOpUp(i: number): number
//
// Dummy Op Up
// Dummy operation to get more opcode budget
// @i - The number to return, necssary to deduplicate the name
// @returns the number (but we do nothing with it)
dummyOpUp:
	proto 1 1

	// contracts/mahber.algo.ts:57
	// return i;
	frame_dig -1 // i: number
	retsub

// scalarMultBase(scalar: bytes): bytes
//
// Scalar Mult Base
// Scalar multiplication of the base point
// @scalar - The scalar to multiply the base point by.
// @returns a point on the curve
scalarMultBase:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/mahber.algo.ts:66
	// result = ecScalarMul(
	//       "BN254g1",
	//       hex(
	//         "00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002"
	//       ),
	//       scalar
	//     )
	byte 0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002
	frame_dig -1 // scalar: bytes
	ec_scalar_mul BN254g1
	frame_bury 0 // result: byte[]

	// contracts/mahber.algo.ts:73
	// return result;
	frame_dig 0 // result: byte[]

	// set the subroutine return value
	frame_bury 0
	retsub

// publicScalarMultBase(byte[])byte[]
abi_route_publicScalarMultBase:
	// The ABI return prefix
	byte 0x151f7c75

	// scalar: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute publicScalarMultBase(byte[])byte[]
	callsub publicScalarMultBase
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// publicScalarMultBase(scalar: bytes): bytes
//
// publicScalarMultBase
// Public wrapper around the scalarMultBase method, allowing it to be tested directly.
// @scalar - The scalar to multiply the basepoint by.
// @returns the content of the scalarMultBase call
publicScalarMultBase:
	proto 1 1

	// contracts/mahber.algo.ts:82
	// return this.scalarMultBase(scalar);
	frame_dig -1 // scalar: bytes
	callsub scalarMultBase
	retsub

// scalarMult(scalar: bytes, point: bytes): bytes
//
// Scalar Mult
// Scalar multiplication with a supplied point
// @scalar - The scalar to multiply the point with
// @point - The point that is multiplied with the scalar
// @returns a point on the curve
scalarMult:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/mahber.algo.ts:92
	// result = ecScalarMul("BN254g1", point, scalar)
	frame_dig -2 // point: bytes
	frame_dig -1 // scalar: bytes
	ec_scalar_mul BN254g1
	frame_bury 0 // result: byte[]

	// contracts/mahber.algo.ts:93
	// return result;
	frame_dig 0 // result: byte[]

	// set the subroutine return value
	frame_bury 0
	retsub

// publicScalarMult(byte[],byte[])byte[]
abi_route_publicScalarMult:
	// The ABI return prefix
	byte 0x151f7c75

	// point: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// scalar: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute publicScalarMult(byte[],byte[])byte[]
	callsub publicScalarMult
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// publicScalarMult(scalar: bytes, point: bytes): bytes
//
// publicScalarMult
// Public wrapper around the scalarMult method, allowing it to be tested directly.
// @scalar - The scalar to multiply the point with
// @point - The point that is multiplied with the scalar
// @returns the content of the scalarMult call
publicScalarMult:
	proto 2 1

	// contracts/mahber.algo.ts:103
	// return this.scalarMult(scalar, point);
	frame_dig -2 // point: bytes
	frame_dig -1 // scalar: bytes
	callsub scalarMult
	retsub

// validPoint(point: bytes): boolean
//
// validPoint
// Checks if the point is valid (on curve)
// @point - The point to check
// @returns true if the point is valid, false otherwise
validPoint:
	proto 1 1

	// contracts/mahber.algo.ts:112
	// return ecSubgroupCheck("BN254g1", point);
	frame_dig -1 // point: bytes
	ec_subgroup_check BN254g1
	retsub

// publicValidPoint(byte[])bool
abi_route_publicValidPoint:
	// The ABI return prefix
	byte 0x151f7c75

	// point: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute publicValidPoint(byte[])bool
	callsub publicValidPoint
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// publicValidPoint(point: bytes): boolean
//
// publicValidPoint
// Public wrapper around the validPoint method, allowing it to be tested directly.
// @point - The point to check
// @returns the content of the validPoint call
publicValidPoint:
	proto 1 1

	// contracts/mahber.algo.ts:121
	// return this.validPoint(point);
	frame_dig -1 // point: bytes
	callsub validPoint
	retsub

// pointAdd(pointA: bytes, pointB: bytes): bytes
//
// Point add
// Adds two points on the curve
// @param pointA - The first point
// @param pointB - The second point
// @returns The result of the operation
pointAdd:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/mahber.algo.ts:131
	// result = ecAdd("BN254g1", pointA, pointB)
	frame_dig -1 // pointA: bytes
	frame_dig -2 // pointB: bytes
	ec_add BN254g1
	frame_bury 0 // result: byte[]

	// contracts/mahber.algo.ts:132
	// return result;
	frame_dig 0 // result: byte[]

	// set the subroutine return value
	frame_bury 0
	retsub

// publicPointAdd(byte[],byte[])byte[]
abi_route_publicPointAdd:
	// The ABI return prefix
	byte 0x151f7c75

	// pointB: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// pointA: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute publicPointAdd(byte[],byte[])byte[]
	callsub publicPointAdd
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// publicPointAdd(pointA: bytes, pointB: bytes): bytes
//
// publicPointAdd
// Public wrapper around the pointAdd method, allowing it to be tested directly.
// @param pointA - The first point
// @param pointB - The second point
// @returns the content of the pointAdd call
publicPointAdd:
	proto 2 1

	// contracts/mahber.algo.ts:142
	// return this.pointAdd(pointA, pointB);
	frame_dig -2 // pointB: bytes
	frame_dig -1 // pointA: bytes
	callsub pointAdd
	retsub

// hashPointToPoint(point: bytes): bytes
//
// hashPointToPoint
// Hashes a point to a point on the curve
// NOTE: ec_map_to maps fp_element to curve point. We use hash and then mod to map the point's X and Y bytes to fp_element first.
// What is inside ec_map_to (accessed Dec 13th 2023):
// https://github.com/algorand/go-algorand/blob/master/data/transactions/logic/pairing.go#L862
// https://pkg.go.dev/github.com/consensys/gnark-crypto/ecc/bn254#MapToG1
// https://github.com/Consensys/gnark-crypto/blob/master/ecc/bn254/fp/element.go#L42
// @param point - The point to hash
// @returns The result of the operation
hashPointToPoint:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/mahber.algo.ts:156
	// hash = sha256(point)
	frame_dig -1 // point: bytes
	sha256
	frame_bury 0 // hash: byte[32]

	// contracts/mahber.algo.ts:157
	// fpElement =
	//       btobigint(hash) % btobigint(hex("30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47"))
	frame_dig 0 // hash: byte[32]
	byte 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47
	b%
	frame_bury 1 // fpElement: bigint

	// contracts/mahber.algo.ts:159
	// result = ecMapTo("BN254g1", rawBytes(fpElement))
	frame_dig 1 // fpElement: bigint
	ec_map_to BN254g1
	frame_bury 2 // result: byte[]

	// contracts/mahber.algo.ts:160
	// return result;
	frame_dig 2 // result: byte[]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// publicHashPointToPoint(byte[])byte[]
abi_route_publicHashPointToPoint:
	// The ABI return prefix
	byte 0x151f7c75

	// point: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute publicHashPointToPoint(byte[])byte[]
	callsub publicHashPointToPoint
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// publicHashPointToPoint(point: bytes): bytes
//
// publicHashPointToPoint
// Public wrapper around the hashPointToPoint method, allowing it to be tested directly.
// @param point - The point to hash
// @returns the content of the hashPointToPoint call
publicHashPointToPoint:
	proto 1 1

	// contracts/mahber.algo.ts:169
	// return this.hashPointToPoint(point);
	frame_dig -1 // point: bytes
	callsub hashPointToPoint
	retsub

// challenge(msg: bytes, nonce: bytes, cPrev: bytes, pk: bytes, keyImage: bytes): bytes
//
// challenge
// Produce the challenge, i.e. an individual link in the ring sig verification.
// We mod by order of fr https://github.com/Consensys/gnark-crypto/blob/master/ecc/bn254/fr/element.go#L42
// c_{i+1} = Hs(m || r_{i} * G + c_{i} * K_{i} || r_{i}*Hp(K_{i}) + c_{i} * I) mod |fr|
// @param msg - The message to be signed
// @param nonce - The nonce, part of the ring signature itself, aka one of the fake secret keys
// @param cPrev - The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)
// @param pk - The specific public key in the ring (indexed from the array of public keys)
// @param keyImage - The key image of the signer, required for linkabiltiy to prevent double spending
// @returns - the challenge
challenge:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/mahber.algo.ts:188
	// left = this.pointAdd(this.scalarMultBase(nonce), this.scalarMult(cPrev, pk))
	frame_dig -4 // pk: bytes
	frame_dig -3 // cPrev: bytes
	callsub scalarMult
	frame_dig -2 // nonce: bytes
	callsub scalarMultBase
	callsub pointAdd
	frame_bury 0 // left: byte[]

	// contracts/mahber.algo.ts:194
	// right = this.pointAdd(this.scalarMult(nonce, this.hashPointToPoint(pk)), this.scalarMult(cPrev, keyImage))
	frame_dig -5 // keyImage: bytes
	frame_dig -3 // cPrev: bytes
	callsub scalarMult
	frame_dig -4 // pk: bytes
	callsub hashPointToPoint
	frame_dig -2 // nonce: bytes
	callsub scalarMult
	callsub pointAdd
	frame_bury 1 // right: byte[]

	// contracts/mahber.algo.ts:200
	// h =
	//       btobigint(sha256(concat(concat(msg, left), right))) %
	//       btobigint(hex("0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001"))
	frame_dig -1 // msg: bytes
	frame_dig 0 // left: byte[]
	concat
	frame_dig 1 // right: byte[]
	concat
	sha256
	byte 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
	b%
	frame_bury 2 // h: bigint

	// contracts/mahber.algo.ts:203
	// return rawBytes(h);
	frame_dig 2 // h: bigint

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]
abi_route_publicChallenge:
	// The ABI return prefix
	byte 0x151f7c75

	// keyImage: byte[]
	txna ApplicationArgs 5
	extract 2 0

	// pk: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// cPrev: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// nonce: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// msg: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]
	callsub publicChallenge
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// publicChallenge(msg: bytes, nonce: bytes, cPrev: bytes, pk: bytes, keyImage: bytes): bytes
//
// publicChallenge
// Public wrapper around the challenge method, allowing it to be tested directly.
// @param msg - The message to be signed
// @param nonce - The nonce, part of the ring signature itself, aka one of the fake secret keys
// @param cPrev - The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)
// @param pk - The specific public key in the ring (indexed from the array of public keys)
// @param keyImage - The key image of the signer, required for linkabiltiy to prevent double spending
// @returns - the content of the privateChallenge call
publicChallenge:
	proto 5 1

	// contracts/mahber.algo.ts:216
	// return this.challenge(msg, nonce, cPrev, pk, keyImage);
	frame_dig -5 // keyImage: bytes
	frame_dig -4 // pk: bytes
	frame_dig -3 // cPrev: bytes
	frame_dig -2 // nonce: bytes
	frame_dig -1 // msg: bytes
	callsub challenge
	retsub

// publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay,byte[])void
abi_route_publicChallengeLsig:
	// output: byte[]
	txna ApplicationArgs 6
	extract 2 0

	// lsigTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// keyImage: byte[]
	txna ApplicationArgs 5
	extract 2 0

	// pk: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// cPrev: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// nonce: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// msg: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay,byte[])void
	callsub publicChallengeLsig
	int 1
	return

// publicChallengeLsig(msg: bytes, nonce: bytes, cPrev: bytes, pk: bytes, keyImage: bytes, lsigTxn: PayTxn, output: bytes): void
//
// publicChallenge
// Public wrapper around the challenge method, allowing it to be tested directly.
// @param msg - The message to be signed
// @param nonce - The nonce, part of the ring signature itself, aka one of the fake secret keys
// @param cPrev - The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)
// @param pk - The specific public key in the Æ’ring (indexed from the array of public keys)
// @param keyImage - The key image of the signer, required for linkabiltiy to prevent double spending
// @returns - the content of the privateChallenge call
publicChallengeLsig:
	proto 7 0

	// contracts/mahber.algo.ts:237
	// verifyTxn(lsigTxn, { sender: Address.fromBytes(MahberChallengeLsig.address()) })
	// verify sender
	frame_dig -6 // lsigTxn: PayTxn
	gtxns Sender
	addr HNDIHHOPQO6XAHJWKUXWEYLFPWTTRNBUJALTJSBVZ66DLKS6OMGKATS3JU
	==
	assert
	retsub

// deposit(pay,byte[])uint64[]
abi_route_deposit:
	// The ABI return prefix
	byte 0x151f7c75

	// pk: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// depositTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute deposit(pay,byte[])uint64[]
	callsub deposit
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// deposit(depositTxn: PayTxn, pk: bytes): uint64[]
//
// deposit
// Deposit funds + public key into the contract
// @param pk - The public key to deposit
// TODO: Add custom EdDSA to check that the depositor knows the secret key. Useful to prevent rogue key attack, adding the negative of another pk.
// @returns - the number id of the public key, if successful. fails if unsuccessful.
deposit:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/mahber.algo.ts:248
	// assert(this.validPoint(pk))
	frame_dig -2 // pk: bytes
	callsub validPoint
	assert

	// contracts/mahber.algo.ts:249
	// assert(!this.hashFilter(pk).exists)
	frame_dig -2 // pk: bytes
	box_len
	swap
	pop
	!
	assert

	// contracts/mahber.algo.ts:251
	// verifyTxn(depositTxn, {
	//       // Ensure the depositor is funding the right amount
	//       receiver: this.app.address,
	//       amount: this.denomination.value,
	//     })
	// verify receiver
	frame_dig -1 // depositTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // depositTxn: PayTxn
	gtxns Amount
	byte 0x64656e6f6d696e6174696f6e // "denomination"
	app_global_get
	==
	assert

	// contracts/mahber.algo.ts:258
	// boxId = this.pkIndex.value / MAX_PK_BOX_PK_NUMBER
	byte 0x706b496e646578 // "pkIndex"
	app_global_get
	int 496
	/
	frame_bury 0 // boxId: uint64

	// if0_condition
	// contracts/mahber.algo.ts:271
	// !this.quickAccessPKBoxes(boxId).exists
	frame_dig 0 // boxId: uint64
	itob
	box_len
	swap
	pop
	!
	bz if0_end

	// if0_consequent
	// contracts/mahber.algo.ts:272
	// this.quickAccessPKBoxes(boxId).create(MAX_PK_BOX_SIZE)
	frame_dig 0 // boxId: uint64
	itob
	int 31744
	box_create
	pop

if0_end:
	// contracts/mahber.algo.ts:276
	// this.quickAccessPKBoxes(boxId).replace((this.pkIndex.value % MAX_PK_BOX_PK_NUMBER) * CURVE_POINT_SIZE, pk)
	frame_dig 0 // boxId: uint64
	itob
	byte 0x706b496e646578 // "pkIndex"
	app_global_get
	int 496
	%
	int 64
	*
	frame_dig -2 // pk: bytes
	box_replace

	// contracts/mahber.algo.ts:279
	// this.hashFilter(pk).create(0)
	frame_dig -2 // pk: bytes
	int 0
	box_create
	pop

	// contracts/mahber.algo.ts:281
	// idx = this.pkIndex.value
	byte 0x706b496e646578 // "pkIndex"
	app_global_get
	frame_bury 1 // idx: uint64

	// contracts/mahber.algo.ts:284
	// this.pkIndex.value = this.pkIndex.value + 1
	byte 0x706b496e646578 // "pkIndex"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// contracts/mahber.algo.ts:286
	// return [idx, boxId];
	frame_dig 1 // idx: uint64
	itob
	frame_dig 0 // boxId: uint64
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// initWithdrawalSession(pay,byte[],byte[])byte[32]
abi_route_initWithdrawalSession:
	// The ABI return prefix
	byte 0x151f7c75

	// initialChallenge: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// msg: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// mbbrDepositTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute initWithdrawalSession(pay,byte[],byte[])byte[32]
	callsub initWithdrawalSession
	concat
	log
	int 1
	return

// initWithdrawalSession(mbbrDepositTxn: PayTxn, msg: bytes, initialChallenge: bytes): bytes32
//
// initWithdrawal
// Creates a box representing a "withdrawal session".
// Of key importance is the signed message string, which must contain the following:
// Ring Size - Chosen number of PKs, i.e. size of anonymity set
// Key Image - The keyimage, the one thing that is unique for a withdrawal
// App Id - The id of the smart contract app
// Nominal amount - The denomination of the contract, what was deposited originally
// ASA ID - Clarifies the ASA ID. (Plain Algo has ID 0, "the default" asset of Algorand)
// Withdrawal Address - Address of the final recipient of the funds
// Relayer Address - Address of the relayer, facilitating the withdrawal (could be same as withdrawal address)
// Relayer Fee - The fee the relayer charges for facilitating the withdrawal (could be 0)
// The hash of the message becomes the id of the withdrawal session's box.
// @param mbbrDepositTxn - The transaction that deposited the MBBR
// @param msg - Signed message
// @param initialChallenge - The initial challenge, which needs to be re-created to verify the ring signature
// @returns - the id of the withdrawal session box
initWithdrawalSession:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/mahber.algo.ts:310
	// id = sha256(msg)
	frame_dig -2 // msg: bytes
	sha256
	frame_bury 0 // id: byte[32]

	// contracts/mahber.algo.ts:311
	// this.sessionsBoxes(id).create(len(msg) + 2 * len(initialChallenge))
	frame_dig 0 // id: byte[32]
	frame_dig -2 // msg: bytes
	len
	int 2
	frame_dig -3 // initialChallenge: bytes
	len
	*
	+
	box_create
	pop

	// contracts/mahber.algo.ts:317
	// return id;
	frame_dig 0 // id: byte[32]

	// set the subroutine return value
	frame_bury 0
	retsub

// createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]
abi_route_createUploadPrecomputedChallengesBox:
	// The ABI return prefix
	byte 0x151f7c75

	// boxSize: uint64
	txna ApplicationArgs 3
	btoi

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// msg: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// mbbrDepositTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]
	callsub createUploadPrecomputedChallengesBox
	concat
	log
	int 1
	return

// createUploadPrecomputedChallengesBox(mbbrDepositTxn: PayTxn, msg: bytes, boxIndex: uint64, boxSize: uint64): bytes32
//
// TODO: destroyWithdrawalSession, IF SESSION LOCKED
// createUploadPrecomputedChallengesBox
// Creates a box that will be used to upload precomputed challenges into.
// @param msg - Msg, functioning as the id for the withdrawal session
// @param boxIndex - The index of the precomputed challenge box, incrementing with each chunk of date.
// @param boxSize - The size of the precomputed challenge box
// @returns - the id of the precomputed challenge box
createUploadPrecomputedChallengesBox:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/mahber.algo.ts:333
	// boxId = sha256(concat(concat(sha256(msg), "precomputedChallenges"), itob(boxIndex)))
	frame_dig -2 // msg: bytes
	sha256
	byte 0x707265636f6d70757465644368616c6c656e676573 // "precomputedChallenges"
	concat
	frame_dig -3 // boxIndex: uint64
	itob
	concat
	sha256
	frame_bury 0 // boxId: byte[32]

	// contracts/mahber.algo.ts:334
	// this.precomputedChallengesBoxes(boxId).create(boxSize)
	frame_dig 0 // boxId: byte[32]
	frame_dig -4 // boxSize: uint64
	box_create
	pop

	// contracts/mahber.algo.ts:335
	// return boxId;
	frame_dig 0 // boxId: byte[32]

	// set the subroutine return value
	frame_bury 0
	retsub

// uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]
abi_route_uploadPrecomputedChallenges:
	// The ABI return prefix
	byte 0x151f7c75

	// precomputedChallenges: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// msg: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]
	callsub uploadPrecomputedChallenges
	concat
	log
	int 1
	return

// uploadPrecomputedChallenges(msg: bytes, boxIndex: uint64, precomputedChallenges: bytes): bytes32
//
// uploadPrecomputedChallenges
// Creates a box and uploads the precomputed challenges into it.
// @param msg - Msg, functioning as the id for the withdrawal session
// @param index - The index of the precomputed challenge box, incrementing with each chunk of date.
// @param precomputedChallenges - The precomputed challenges
// @returns - the id of the precomputed challenge box
uploadPrecomputedChallenges:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/mahber.algo.ts:348
	// boxId = sha256(concat(concat(sha256(msg), "precomputedChallenges"), itob(boxIndex)))
	frame_dig -1 // msg: bytes
	sha256
	byte 0x707265636f6d70757465644368616c6c656e676573 // "precomputedChallenges"
	concat
	frame_dig -2 // boxIndex: uint64
	itob
	concat
	sha256
	frame_bury 0 // boxId: byte[32]

	// contracts/mahber.algo.ts:349
	// this.precomputedChallengesBoxes(boxId).replace(0, precomputedChallenges)
	frame_dig 0 // boxId: byte[32]
	int 0
	frame_dig -3 // precomputedChallenges: bytes
	box_replace

	// contracts/mahber.algo.ts:350
	// return boxId;
	frame_dig 0 // boxId: byte[32]

	// set the subroutine return value
	frame_bury 0
	retsub

// createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]
abi_route_createIntermediateChallengesBox:
	// The ABI return prefix
	byte 0x151f7c75

	// boxSize: uint64
	txna ApplicationArgs 3
	btoi

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// msg: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// mbbrDepositTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]
	callsub createIntermediateChallengesBox
	concat
	log
	int 1
	return

// createIntermediateChallengesBox(mbbrDepositTxn: PayTxn, msg: bytes, boxIndex: uint64, boxSize: uint64): bytes32
//
// createIntermediateChallengesBox
// Creates a box that will be used to contain intermediateChallengesBox.
// Should eventually be a mirror image of the corresponding uploadPrecomputedChallengesBox.
// @param msg - Msg, functioning as the id for the withdrawal session
// @param boxIndex - The index of the precomputed challenge box, incrementing with each chunk of date.
// @param boxSize - The size of the precomputed challenge box
// @returns - the id of the precomputed challenge box
createIntermediateChallengesBox:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/mahber.algo.ts:365
	// boxId = sha256(concat(concat(sha256(msg), "intermediateChallenges"), itob(boxIndex)))
	frame_dig -2 // msg: bytes
	sha256
	byte 0x696e7465726d6564696174654368616c6c656e676573 // "intermediateChallenges"
	concat
	frame_dig -3 // boxIndex: uint64
	itob
	concat
	sha256
	frame_bury 0 // boxId: byte[32]

	// contracts/mahber.algo.ts:366
	// this.precomputedChallengesBoxes(boxId).create(boxSize)
	frame_dig 0 // boxId: byte[32]
	frame_dig -4 // boxSize: uint64
	box_create
	pop

	// contracts/mahber.algo.ts:367
	// return boxId;
	frame_dig 0 // boxId: byte[32]

	// set the subroutine return value
	frame_bury 0
	retsub

// computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)
abi_route_computeIndividualChallenge:
	// The ABI return prefix
	byte 0x151f7c75

	// cPrevOffset: uint64
	txna ApplicationArgs 6
	btoi

	// cPrevBoxIndex: uint64
	txna ApplicationArgs 5
	btoi

	// keyImage: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// pkIndex: uint64
	txna ApplicationArgs 3
	btoi

	// nonce: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// msg: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)
	callsub computeIndividualChallenge
	concat
	log
	int 1
	return

// computeIndividualChallenge(msg: bytes, nonce: bytes, pkIndex: uint64, keyImage: bytes, cPrevBoxIndex: uint64, cPrevOffset: uint64): [bytes32, uint64]
//
// computeIndividualChallenge
// Computes an individual challenge.
// Note that the previous challenge is loaded specifically from the precomputed challenges box.
// While the calculated challenge is loaded into the intermediate challenges box.
// At the end we will compare if the two boxes are the same, and of course that the last challenge is the same as the initial challenge.
// By loading specifically from the precomputed challenges box we can verify in parallell.
// The odds of being able to arrive at the same initial challenge in the last challenge is astronomically low UNLESS it is a valid ring signature.
// Public keys are of course loaded from the contract storage.
// @param msg - The message to be signed
// @param nonce - The nonce, part of the ring signature itself, aka one of the fake secret keys
// @param pkIndex- The index number of the public key in the smart contract storage
// @param keyImage - The key image of the signer, required for linkabiltiy to prevent double spending
// @param cPrevIndex - The index of the previous challenge, allowing it to be loaded from the loaded precomputed challenges box
// @returns - ...
computeIndividualChallenge:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// contracts/mahber.algo.ts:398
	// pkBoxId = pkIndex / MAX_PK_BOX_PK_NUMBER
	frame_dig -3 // pkIndex: uint64
	int 496
	/
	frame_bury 0 // pkBoxId: uint64

	// contracts/mahber.algo.ts:399
	// pkOffset = (pkIndex % MAX_PK_BOX_PK_NUMBER) * CURVE_POINT_SIZE
	frame_dig -3 // pkIndex: uint64
	int 496
	%
	int 64
	*
	frame_bury 1 // pkOffset: uint64

	// contracts/mahber.algo.ts:400
	// pk = this.quickAccessPKBoxes(pkBoxId).extract(pkOffset, pkOffset + CURVE_POINT_SIZE)
	frame_dig 0 // pkBoxId: uint64
	itob
	frame_dig 1 // pkOffset: uint64
	frame_dig 1 // pkOffset: uint64
	int 64
	+
	box_extract
	frame_bury 2 // pk: byte[]

	// contracts/mahber.algo.ts:402
	// cPrevBoxId = sha256(concat(concat(sha256(msg), "precomputedChallenges"), itob(cPrevBoxIndex)))
	frame_dig -1 // msg: bytes
	sha256
	byte 0x707265636f6d70757465644368616c6c656e676573 // "precomputedChallenges"
	concat
	frame_dig -5 // cPrevBoxIndex: uint64
	itob
	concat
	sha256
	frame_bury 3 // cPrevBoxId: byte[32]

	// contracts/mahber.algo.ts:403
	// cPrev = this.precomputedChallengesBoxes(cPrevBoxId).extract(cPrevOffset, cPrevOffset + CHALLENGE_SIZE)
	frame_dig 3 // cPrevBoxId: byte[32]
	frame_dig -6 // cPrevOffset: uint64
	frame_dig -6 // cPrevOffset: uint64
	int 32
	+
	box_extract
	frame_bury 4 // cPrev: byte[]

	// contracts/mahber.algo.ts:405
	// computedChallenge = this.challenge(msg, nonce, cPrev, pk, keyImage)
	frame_dig -4 // keyImage: bytes
	frame_dig 2 // pk: byte[]
	frame_dig 4 // cPrev: byte[]
	frame_dig -2 // nonce: bytes
	frame_dig -1 // msg: bytes
	callsub challenge
	frame_bury 5 // computedChallenge: byte[]

	// contracts/mahber.algo.ts:407
	// intermediateChallengesBoxIndex = cPrevBoxIndex
	frame_dig -5 // cPrevBoxIndex: uint64
	frame_bury 6 // intermediateChallengesBoxIndex: uint64

	// contracts/mahber.algo.ts:408
	// intermediateChallengesBoxOffset = cPrevOffset + CHALLENGE_SIZE
	frame_dig -6 // cPrevOffset: uint64
	int 32
	+
	frame_bury 7 // intermediateChallengesBoxOffset: uint64

	// if1_condition
	// contracts/mahber.algo.ts:409
	// intermediateChallengesBoxOffset === MAX_BOX_BYTES
	frame_dig 7 // intermediateChallengesBoxOffset: uint64
	int 32768
	==
	bz if1_end

	// if1_consequent
	// contracts/mahber.algo.ts:411
	// intermediateChallengesBoxIndex = intermediateChallengesBoxIndex + 1
	frame_dig 6 // intermediateChallengesBoxIndex: uint64
	int 1
	+
	frame_bury 6 // intermediateChallengesBoxIndex: uint64

	// contracts/mahber.algo.ts:412
	// intermediateChallengesBoxOffset = 0
	int 0
	frame_bury 7 // intermediateChallengesBoxOffset: uint64

if1_end:
	// contracts/mahber.algo.ts:420
	// intermediateChallengesBoxId = sha256(
	//       concat(concat(sha256(msg), "precomputedChallenges"), itob(intermediateChallengesBoxIndex))
	//     )
	frame_dig -1 // msg: bytes
	sha256
	byte 0x707265636f6d70757465644368616c6c656e676573 // "precomputedChallenges"
	concat
	frame_dig 6 // intermediateChallengesBoxIndex: uint64
	itob
	concat
	sha256
	frame_bury 8 // intermediateChallengesBoxId: byte[32]

	// contracts/mahber.algo.ts:423
	// this.intermediateChallengesBoxes(intermediateChallengesBoxId).replace(
	//       intermediateChallengesBoxOffset,
	//       computedChallenge
	//     )
	frame_dig 8 // intermediateChallengesBoxId: byte[32]
	frame_dig 7 // intermediateChallengesBoxOffset: uint64
	frame_dig 5 // computedChallenge: byte[]
	box_replace

	// contracts/mahber.algo.ts:427
	// return [intermediateChallengesBoxId, intermediateChallengesBoxOffset];
	frame_dig 8 // intermediateChallengesBoxId: byte[32]
	frame_dig 7 // intermediateChallengesBoxOffset: uint64
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "dummyOpUp(uint64)uint64"
	method "publicScalarMultBase(byte[])byte[]"
	method "publicScalarMult(byte[],byte[])byte[]"
	method "publicValidPoint(byte[])bool"
	method "publicPointAdd(byte[],byte[])byte[]"
	method "publicHashPointToPoint(byte[])byte[]"
	method "publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]"
	method "publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay,byte[])void"
	method "deposit(pay,byte[])uint64[]"
	method "initWithdrawalSession(pay,byte[],byte[])byte[32]"
	method "createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]"
	method "uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]"
	method "createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]"
	method "computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)"
	txna ApplicationArgs 0
	match abi_route_dummyOpUp abi_route_publicScalarMultBase abi_route_publicScalarMult abi_route_publicValidPoint abi_route_publicPointAdd abi_route_publicHashPointToPoint abi_route_publicChallenge abi_route_publicChallengeLsig abi_route_deposit abi_route_initWithdrawalSession abi_route_createUploadPrecomputedChallengesBox abi_route_uploadPrecomputedChallenges abi_route_createIntermediateChallengesBox abi_route_computeIndividualChallenge
	err