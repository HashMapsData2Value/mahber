{
  "name": "Mahber",
  "desc": "",
  "methods": [
    {
      "name": "dummyOpUp",
      "args": [
        {
          "name": "i",
          "type": "uint64",
          "desc": ""
        }
      ],
      "desc": "Dummy Op UpDummy operation to get more opcode budget@i- The number to return, necssary to deduplicate the name",
      "returns": {
        "type": "uint64",
        "desc": "the number (but we do nothing with it)"
      }
    },
    {
      "name": "challenge",
      "args": [
        {
          "name": "msg",
          "type": "byte[]",
          "desc": "The message to be signed"
        },
        {
          "name": "nonce",
          "type": "byte[]",
          "desc": "The nonce, part of the ring signature itself, aka one of the fake secret keys"
        },
        {
          "name": "cPrev",
          "type": "byte[]",
          "desc": "The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)"
        },
        {
          "name": "pk",
          "type": "byte[]",
          "desc": "The specific public key in the ring (indexed from the array of public keys)"
        },
        {
          "name": "keyImage",
          "type": "byte[]",
          "desc": "The key image of the signer, required for linkabiltiy to prevent double spending"
        }
      ],
      "desc": "challenge2Produce the challenge, i.e. an individual link in the ring sig verification.We mod by order of fr https://github.com/Consensys/gnark-crypto/blob/master/ecc/bn254/fr/element.go#L42c_{i+1}= Hs(m || r_{i}* G + c_{i}* K_{i}|| r_{i}*Hp(K_{i}) + c_{i}* I) mod |fr|",
      "returns": {
        "type": "byte[]",
        "desc": ""
      }
    },
    {
      "name": "createApplication",
      "desc": "",
      "returns": {
        "type": "void",
        "desc": ""
      },
      "args": []
    }
  ]
}