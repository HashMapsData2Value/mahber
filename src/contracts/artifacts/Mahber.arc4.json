{
  "name": "Mahber",
  "desc": "",
  "methods": [
    {
      "name": "createApplication",
      "args": [],
      "desc": "",
      "returns": {
        "type": "void",
        "desc": ""
      }
    },
    {
      "name": "dummyOpUp",
      "args": [
        {
          "name": "i",
          "type": "uint64",
          "desc": ""
        }
      ],
      "desc": "Dummy Op UpDummy operation to get more opcode budget@i- The number to return, necssary to deduplicate the name",
      "returns": {
        "type": "uint64",
        "desc": "the number (but we do nothing with it)"
      }
    },
    {
      "name": "publicScalarMultBase",
      "args": [
        {
          "name": "scalar",
          "type": "byte[]",
          "desc": ""
        }
      ],
      "desc": "publicScalarMultBasePublic wrapper around the scalarMultBase method, allowing it to be tested directly.@scalar- The scalar to multiply the basepoint by.",
      "returns": {
        "type": "byte[]",
        "desc": "the content of the scalarMultBase call"
      }
    },
    {
      "name": "publicScalarMult",
      "args": [
        {
          "name": "scalar",
          "type": "byte[]",
          "desc": ""
        },
        {
          "name": "point",
          "type": "byte[]",
          "desc": ""
        }
      ],
      "desc": "publicScalarMultPublic wrapper around the scalarMult method, allowing it to be tested directly.@scalar- The scalar to multiply the point with@point- The point that is multiplied with the scalar",
      "returns": {
        "type": "byte[]",
        "desc": "the content of the scalarMult call"
      }
    },
    {
      "name": "publicValidPoint",
      "args": [
        {
          "name": "point",
          "type": "byte[]",
          "desc": ""
        }
      ],
      "desc": "publicValidPointPublic wrapper around the validPoint method, allowing it to be tested directly.@point- The point to check",
      "returns": {
        "type": "bool",
        "desc": "the content of the validPoint call"
      }
    },
    {
      "name": "publicPointAdd",
      "args": [
        {
          "name": "pointA",
          "type": "byte[]",
          "desc": "The first point"
        },
        {
          "name": "pointB",
          "type": "byte[]",
          "desc": "The second point"
        }
      ],
      "desc": "publicPointAddPublic wrapper around the pointAdd method, allowing it to be tested directly.",
      "returns": {
        "type": "byte[]",
        "desc": "the content of the pointAdd call"
      }
    },
    {
      "name": "publicHashPointToPoint",
      "args": [
        {
          "name": "point",
          "type": "byte[]",
          "desc": "The point to hash"
        }
      ],
      "desc": "publicHashPointToPointPublic wrapper around the hashPointToPoint method, allowing it to be tested directly.",
      "returns": {
        "type": "byte[]",
        "desc": "the content of the hashPointToPoint call"
      }
    },
    {
      "name": "publicChallenge",
      "args": [
        {
          "name": "msg",
          "type": "byte[]",
          "desc": "The message to be signed"
        },
        {
          "name": "nonce",
          "type": "byte[]",
          "desc": "The nonce, part of the ring signature itself, aka one of the fake secret keys"
        },
        {
          "name": "cPrev",
          "type": "byte[]",
          "desc": "The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)"
        },
        {
          "name": "pk",
          "type": "byte[]",
          "desc": "The specific public key in the ring (indexed from the array of public keys)"
        },
        {
          "name": "keyImage",
          "type": "byte[]",
          "desc": "The key image of the signer, required for linkabiltiy to prevent double spending"
        }
      ],
      "desc": "publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.",
      "returns": {
        "type": "byte[]",
        "desc": "- the content of the privateChallenge call"
      }
    },
    {
      "name": "deposit",
      "args": [
        {
          "name": "depositTxn",
          "type": "pay",
          "desc": ""
        },
        {
          "name": "pk",
          "type": "byte[]",
          "desc": "The public key to depositTODO: Add custom EdDSA to check that the depositor knows the secret key. Useful to prevent rogue key attack, adding the negative of another pk."
        }
      ],
      "desc": "depositDeposit funds + public key into the contract",
      "returns": {
        "type": "uint64[]",
        "desc": "- the number id of the public key, if successful. fails if unsuccessful."
      }
    }
  ]
}