/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  CoreAppCallArgs,
  RawAppCallArgs,
  AppState,
  TealTemplateParams,
  ABIAppCallArg,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'
import type { TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "dummyOpUp(uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "publicScalarMultBase(byte[])byte[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "publicScalarMult(byte[],byte[])byte[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "publicValidPoint(byte[])bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "publicPointAdd(byte[],byte[])byte[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "publicHashPointToPoint(byte[])byte[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "deposit(pay,byte[])uint64[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "initWithdrawalSession(pay,byte[],byte[])byte[32]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "denomination": {
          "type": "uint64",
          "key": "denomination"
        },
        "asaId": {
          "type": "uint64",
          "key": "asaId"
        },
        "pkIndex": {
          "type": "uint64",
          "key": "pkIndex"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 3
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjc5LjAKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbG1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICJOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQppbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggY2FsbF9Ob09wIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgY3JlYXRlX05vT3AgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRAoKTk9UX0lNUExFTUVOVEVEOgoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBleGVjdXRlIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCgljYWxsc3ViIGNyZWF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpOiB2b2lkCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjQ1CgkvLyB0aGlzLmRlbm9taW5hdGlvbi52YWx1ZSA9IDEwMDAgKiAxMDAwMDAwCglieXRlIDB4NjQ2NTZlNmY2ZDY5NmU2MTc0Njk2ZjZlIC8vICJkZW5vbWluYXRpb24iCglpbnQgMTAwMDAwMDAwMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6NDYKCS8vIHRoaXMuYXNhSWQudmFsdWUgPSAwCglieXRlIDB4NjE3MzYxNDk2NCAvLyAiYXNhSWQiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6NDcKCS8vIHRoaXMucGtJbmRleC52YWx1ZSA9IDAKCWJ5dGUgMHg3MDZiNDk2ZTY0NjU3OCAvLyAicGtJbmRleCIKCWludCAwCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBkdW1teU9wVXAodWludDY0KXVpbnQ2NAphYmlfcm91dGVfZHVtbXlPcFVwOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBpOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGR1bW15T3BVcCh1aW50NjQpdWludDY0CgljYWxsc3ViIGR1bW15T3BVcAoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGR1bW15T3BVcChpOiBudW1iZXIpOiBudW1iZXIKLy8KLy8gRHVtbXkgT3AgVXAKLy8gRHVtbXkgb3BlcmF0aW9uIHRvIGdldCBtb3JlIG9wY29kZSBidWRnZXQKLy8gQGkgLSBUaGUgbnVtYmVyIHRvIHJldHVybiwgbmVjc3NhcnkgdG8gZGVkdXBsaWNhdGUgdGhlIG5hbWUKLy8gQHJldHVybnMgdGhlIG51bWJlciAoYnV0IHdlIGRvIG5vdGhpbmcgd2l0aCBpdCkKZHVtbXlPcFVwOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjU2CgkvLyByZXR1cm4gaTsKCWZyYW1lX2RpZyAtMSAvLyBpOiBudW1iZXIKCXJldHN1YgoKLy8gc2NhbGFyTXVsdEJhc2Uoc2NhbGFyOiBieXRlcyk6IGJ5dGVzCi8vCi8vIFNjYWxhciBNdWx0IEJhc2UKLy8gU2NhbGFyIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBiYXNlIHBvaW50Ci8vIEBzY2FsYXIgLSBUaGUgc2NhbGFyIHRvIG11bHRpcGx5IHRoZSBiYXNlIHBvaW50IGJ5LgovLyBAcmV0dXJucyBhIHBvaW50IG9uIHRoZSBjdXJ2ZQpzY2FsYXJNdWx0QmFzZToKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjY1CgkvLyByZXN1bHQgPSBlY1NjYWxhck11bCgKCS8vICAgICAgICJCTjI1NGcxIiwKCS8vICAgICAgIGhleCgKCS8vICAgICAgICAgIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyIgoJLy8gICAgICAgKSwKCS8vICAgICAgIHNjYWxhcgoJLy8gICAgICkKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMgoJZnJhbWVfZGlnIC0xIC8vIHNjYWxhcjogYnl0ZXMKCWVjX3NjYWxhcl9tdWwgQk4yNTRnMQoJZnJhbWVfYnVyeSAwIC8vIHJlc3VsdDogYnl0ZVtdCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjcyCgkvLyByZXR1cm4gcmVzdWx0OwoJZnJhbWVfZGlnIDAgLy8gcmVzdWx0OiBieXRlW10KCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gcHVibGljU2NhbGFyTXVsdEJhc2UoYnl0ZVtdKWJ5dGVbXQphYmlfcm91dGVfcHVibGljU2NhbGFyTXVsdEJhc2U6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIHNjYWxhcjogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgcHVibGljU2NhbGFyTXVsdEJhc2UoYnl0ZVtdKWJ5dGVbXQoJY2FsbHN1YiBwdWJsaWNTY2FsYXJNdWx0QmFzZQoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBwdWJsaWNTY2FsYXJNdWx0QmFzZShzY2FsYXI6IGJ5dGVzKTogYnl0ZXMKLy8KLy8gcHVibGljU2NhbGFyTXVsdEJhc2UKLy8gUHVibGljIHdyYXBwZXIgYXJvdW5kIHRoZSBzY2FsYXJNdWx0QmFzZSBtZXRob2QsIGFsbG93aW5nIGl0IHRvIGJlIHRlc3RlZCBkaXJlY3RseS4KLy8gQHNjYWxhciAtIFRoZSBzY2FsYXIgdG8gbXVsdGlwbHkgdGhlIGJhc2Vwb2ludCBieS4KLy8gQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHNjYWxhck11bHRCYXNlIGNhbGwKcHVibGljU2NhbGFyTXVsdEJhc2U6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6ODEKCS8vIHJldHVybiB0aGlzLnNjYWxhck11bHRCYXNlKHNjYWxhcik7CglmcmFtZV9kaWcgLTEgLy8gc2NhbGFyOiBieXRlcwoJY2FsbHN1YiBzY2FsYXJNdWx0QmFzZQoJcmV0c3ViCgovLyBzY2FsYXJNdWx0KHNjYWxhcjogYnl0ZXMsIHBvaW50OiBieXRlcyk6IGJ5dGVzCi8vCi8vIFNjYWxhciBNdWx0Ci8vIFNjYWxhciBtdWx0aXBsaWNhdGlvbiB3aXRoIGEgc3VwcGxpZWQgcG9pbnQKLy8gQHNjYWxhciAtIFRoZSBzY2FsYXIgdG8gbXVsdGlwbHkgdGhlIHBvaW50IHdpdGgKLy8gQHBvaW50IC0gVGhlIHBvaW50IHRoYXQgaXMgbXVsdGlwbGllZCB3aXRoIHRoZSBzY2FsYXIKLy8gQHJldHVybnMgYSBwb2ludCBvbiB0aGUgY3VydmUKc2NhbGFyTXVsdDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjkxCgkvLyByZXN1bHQgPSBlY1NjYWxhck11bCgiQk4yNTRnMSIsIHBvaW50LCBzY2FsYXIpCglmcmFtZV9kaWcgLTIgLy8gcG9pbnQ6IGJ5dGVzCglmcmFtZV9kaWcgLTEgLy8gc2NhbGFyOiBieXRlcwoJZWNfc2NhbGFyX211bCBCTjI1NGcxCglmcmFtZV9idXJ5IDAgLy8gcmVzdWx0OiBieXRlW10KCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6OTIKCS8vIHJldHVybiByZXN1bHQ7CglmcmFtZV9kaWcgMCAvLyByZXN1bHQ6IGJ5dGVbXQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBwdWJsaWNTY2FsYXJNdWx0KGJ5dGVbXSxieXRlW10pYnl0ZVtdCmFiaV9yb3V0ZV9wdWJsaWNTY2FsYXJNdWx0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBwb2ludDogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIHNjYWxhcjogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgcHVibGljU2NhbGFyTXVsdChieXRlW10sYnl0ZVtdKWJ5dGVbXQoJY2FsbHN1YiBwdWJsaWNTY2FsYXJNdWx0CglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIHB1YmxpY1NjYWxhck11bHQoc2NhbGFyOiBieXRlcywgcG9pbnQ6IGJ5dGVzKTogYnl0ZXMKLy8KLy8gcHVibGljU2NhbGFyTXVsdAovLyBQdWJsaWMgd3JhcHBlciBhcm91bmQgdGhlIHNjYWxhck11bHQgbWV0aG9kLCBhbGxvd2luZyBpdCB0byBiZSB0ZXN0ZWQgZGlyZWN0bHkuCi8vIEBzY2FsYXIgLSBUaGUgc2NhbGFyIHRvIG11bHRpcGx5IHRoZSBwb2ludCB3aXRoCi8vIEBwb2ludCAtIFRoZSBwb2ludCB0aGF0IGlzIG11bHRpcGxpZWQgd2l0aCB0aGUgc2NhbGFyCi8vIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBzY2FsYXJNdWx0IGNhbGwKcHVibGljU2NhbGFyTXVsdDoKCXByb3RvIDIgMQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czoxMDIKCS8vIHJldHVybiB0aGlzLnNjYWxhck11bHQoc2NhbGFyLCBwb2ludCk7CglmcmFtZV9kaWcgLTIgLy8gcG9pbnQ6IGJ5dGVzCglmcmFtZV9kaWcgLTEgLy8gc2NhbGFyOiBieXRlcwoJY2FsbHN1YiBzY2FsYXJNdWx0CglyZXRzdWIKCi8vIHZhbGlkUG9pbnQocG9pbnQ6IGJ5dGVzKTogYm9vbGVhbgovLwovLyB2YWxpZFBvaW50Ci8vIENoZWNrcyBpZiB0aGUgcG9pbnQgaXMgdmFsaWQgKG9uIGN1cnZlKQovLyBAcG9pbnQgLSBUaGUgcG9pbnQgdG8gY2hlY2sKLy8gQHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZQp2YWxpZFBvaW50OgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjExMQoJLy8gcmV0dXJuIGVjU3ViZ3JvdXBDaGVjaygiQk4yNTRnMSIsIHBvaW50KTsKCWZyYW1lX2RpZyAtMSAvLyBwb2ludDogYnl0ZXMKCWVjX3N1Ymdyb3VwX2NoZWNrIEJOMjU0ZzEKCXJldHN1YgoKLy8gcHVibGljVmFsaWRQb2ludChieXRlW10pYm9vbAphYmlfcm91dGVfcHVibGljVmFsaWRQb2ludDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gcG9pbnQ6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIHB1YmxpY1ZhbGlkUG9pbnQoYnl0ZVtdKWJvb2wKCWNhbGxzdWIgcHVibGljVmFsaWRQb2ludAoJYnl0ZSAweDAwCglpbnQgMAoJdW5jb3ZlciAyCglzZXRiaXQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBwdWJsaWNWYWxpZFBvaW50KHBvaW50OiBieXRlcyk6IGJvb2xlYW4KLy8KLy8gcHVibGljVmFsaWRQb2ludAovLyBQdWJsaWMgd3JhcHBlciBhcm91bmQgdGhlIHZhbGlkUG9pbnQgbWV0aG9kLCBhbGxvd2luZyBpdCB0byBiZSB0ZXN0ZWQgZGlyZWN0bHkuCi8vIEBwb2ludCAtIFRoZSBwb2ludCB0byBjaGVjawovLyBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWRQb2ludCBjYWxsCnB1YmxpY1ZhbGlkUG9pbnQ6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MTIwCgkvLyByZXR1cm4gdGhpcy52YWxpZFBvaW50KHBvaW50KTsKCWZyYW1lX2RpZyAtMSAvLyBwb2ludDogYnl0ZXMKCWNhbGxzdWIgdmFsaWRQb2ludAoJcmV0c3ViCgovLyBwb2ludEFkZChwb2ludEE6IGJ5dGVzLCBwb2ludEI6IGJ5dGVzKTogYnl0ZXMKLy8KLy8gUG9pbnQgYWRkCi8vIEFkZHMgdHdvIHBvaW50cyBvbiB0aGUgY3VydmUKLy8gQHBhcmFtIHBvaW50QSAtIFRoZSBmaXJzdCBwb2ludAovLyBAcGFyYW0gcG9pbnRCIC0gVGhlIHNlY29uZCBwb2ludAovLyBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb24KcG9pbnRBZGQ6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czoxMzAKCS8vIHJlc3VsdCA9IGVjQWRkKCJCTjI1NGcxIiwgcG9pbnRBLCBwb2ludEIpCglmcmFtZV9kaWcgLTEgLy8gcG9pbnRBOiBieXRlcwoJZnJhbWVfZGlnIC0yIC8vIHBvaW50QjogYnl0ZXMKCWVjX2FkZCBCTjI1NGcxCglmcmFtZV9idXJ5IDAgLy8gcmVzdWx0OiBieXRlW10KCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MTMxCgkvLyByZXR1cm4gcmVzdWx0OwoJZnJhbWVfZGlnIDAgLy8gcmVzdWx0OiBieXRlW10KCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gcHVibGljUG9pbnRBZGQoYnl0ZVtdLGJ5dGVbXSlieXRlW10KYWJpX3JvdXRlX3B1YmxpY1BvaW50QWRkOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBwb2ludEI6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBwb2ludEE6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIHB1YmxpY1BvaW50QWRkKGJ5dGVbXSxieXRlW10pYnl0ZVtdCgljYWxsc3ViIHB1YmxpY1BvaW50QWRkCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIHB1YmxpY1BvaW50QWRkKHBvaW50QTogYnl0ZXMsIHBvaW50QjogYnl0ZXMpOiBieXRlcwovLwovLyBwdWJsaWNQb2ludEFkZAovLyBQdWJsaWMgd3JhcHBlciBhcm91bmQgdGhlIHBvaW50QWRkIG1ldGhvZCwgYWxsb3dpbmcgaXQgdG8gYmUgdGVzdGVkIGRpcmVjdGx5LgovLyBAcGFyYW0gcG9pbnRBIC0gVGhlIGZpcnN0IHBvaW50Ci8vIEBwYXJhbSBwb2ludEIgLSBUaGUgc2Vjb25kIHBvaW50Ci8vIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBwb2ludEFkZCBjYWxsCnB1YmxpY1BvaW50QWRkOgoJcHJvdG8gMiAxCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjE0MQoJLy8gcmV0dXJuIHRoaXMucG9pbnRBZGQocG9pbnRBLCBwb2ludEIpOwoJZnJhbWVfZGlnIC0yIC8vIHBvaW50QjogYnl0ZXMKCWZyYW1lX2RpZyAtMSAvLyBwb2ludEE6IGJ5dGVzCgljYWxsc3ViIHBvaW50QWRkCglyZXRzdWIKCi8vIGhhc2hQb2ludFRvUG9pbnQocG9pbnQ6IGJ5dGVzKTogYnl0ZXMKLy8KLy8gaGFzaFBvaW50VG9Qb2ludAovLyBIYXNoZXMgYSBwb2ludCB0byBhIHBvaW50IG9uIHRoZSBjdXJ2ZQovLyBOT1RFOiBlY19tYXBfdG8gbWFwcyBmcF9lbGVtZW50IHRvIGN1cnZlIHBvaW50LiBXZSB1c2UgaGFzaCBhbmQgdGhlbiBtb2QgdG8gbWFwIHRoZSBwb2ludCdzIFggYW5kIFkgYnl0ZXMgdG8gZnBfZWxlbWVudCBmaXJzdC4KLy8gV2hhdCBpcyBpbnNpZGUgZWNfbWFwX3RvIChhY2Nlc3NlZCBEZWMgMTN0aCAyMDIzKToKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kL2dvLWFsZ29yYW5kL2Jsb2IvbWFzdGVyL2RhdGEvdHJhbnNhY3Rpb25zL2xvZ2ljL3BhaXJpbmcuZ28jTDg2MgovLyBodHRwczovL3BrZy5nby5kZXYvZ2l0aHViLmNvbS9jb25zZW5zeXMvZ25hcmstY3J5cHRvL2VjYy9ibjI1NCNNYXBUb0cxCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Db25zZW5zeXMvZ25hcmstY3J5cHRvL2Jsb2IvbWFzdGVyL2VjYy9ibjI1NC9mcC9lbGVtZW50LmdvI0w0MgovLyBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gaGFzaAovLyBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb24KaGFzaFBvaW50VG9Qb2ludDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDMKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MTU1CgkvLyBoYXNoID0gc2hhMjU2KHBvaW50KQoJZnJhbWVfZGlnIC0xIC8vIHBvaW50OiBieXRlcwoJc2hhMjU2CglmcmFtZV9idXJ5IDAgLy8gaGFzaDogYnl0ZVszMl0KCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MTU2CgkvLyBmcEVsZW1lbnQgPQoJLy8gICAgICAgYnRvYmlnaW50KGhhc2gpICUgYnRvYmlnaW50KGhleCgiMzA2NDRlNzJlMTMxYTAyOWI4NTA0NWI2ODE4MTU4NWQ5NzgxNmE5MTY4NzFjYThkM2MyMDhjMTZkODdjZmQ0NyIpKQoJZnJhbWVfZGlnIDAgLy8gaGFzaDogYnl0ZVszMl0KCWJ5dGUgMHgzMDY0NGU3MmUxMzFhMDI5Yjg1MDQ1YjY4MTgxNTg1ZDk3ODE2YTkxNjg3MWNhOGQzYzIwOGMxNmQ4N2NmZDQ3CgliJQoJZnJhbWVfYnVyeSAxIC8vIGZwRWxlbWVudDogYmlnaW50CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjE1OAoJLy8gcmVzdWx0ID0gZWNNYXBUbygiQk4yNTRnMSIsIHJhd0J5dGVzKGZwRWxlbWVudCkpCglmcmFtZV9kaWcgMSAvLyBmcEVsZW1lbnQ6IGJpZ2ludAoJZWNfbWFwX3RvIEJOMjU0ZzEKCWZyYW1lX2J1cnkgMiAvLyByZXN1bHQ6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czoxNTkKCS8vIHJldHVybiByZXN1bHQ7CglmcmFtZV9kaWcgMiAvLyByZXN1bHQ6IGJ5dGVbXQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKLy8gcHVibGljSGFzaFBvaW50VG9Qb2ludChieXRlW10pYnl0ZVtdCmFiaV9yb3V0ZV9wdWJsaWNIYXNoUG9pbnRUb1BvaW50OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBwb2ludDogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgcHVibGljSGFzaFBvaW50VG9Qb2ludChieXRlW10pYnl0ZVtdCgljYWxsc3ViIHB1YmxpY0hhc2hQb2ludFRvUG9pbnQKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gcHVibGljSGFzaFBvaW50VG9Qb2ludChwb2ludDogYnl0ZXMpOiBieXRlcwovLwovLyBwdWJsaWNIYXNoUG9pbnRUb1BvaW50Ci8vIFB1YmxpYyB3cmFwcGVyIGFyb3VuZCB0aGUgaGFzaFBvaW50VG9Qb2ludCBtZXRob2QsIGFsbG93aW5nIGl0IHRvIGJlIHRlc3RlZCBkaXJlY3RseS4KLy8gQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGhhc2gKLy8gQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIGhhc2hQb2ludFRvUG9pbnQgY2FsbApwdWJsaWNIYXNoUG9pbnRUb1BvaW50OgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjE2OAoJLy8gcmV0dXJuIHRoaXMuaGFzaFBvaW50VG9Qb2ludChwb2ludCk7CglmcmFtZV9kaWcgLTEgLy8gcG9pbnQ6IGJ5dGVzCgljYWxsc3ViIGhhc2hQb2ludFRvUG9pbnQKCXJldHN1YgoKLy8gY2hhbGxlbmdlKG1zZzogYnl0ZXMsIG5vbmNlOiBieXRlcywgY1ByZXY6IGJ5dGVzLCBwazogYnl0ZXMsIGtleUltYWdlOiBieXRlcyk6IGJ5dGVzCi8vCi8vIGNoYWxsZW5nZQovLyBQcm9kdWNlIHRoZSBjaGFsbGVuZ2UsIGkuZS4gYW4gaW5kaXZpZHVhbCBsaW5rIGluIHRoZSByaW5nIHNpZyB2ZXJpZmljYXRpb24uCi8vIFdlIG1vZCBieSBvcmRlciBvZiBmciBodHRwczovL2dpdGh1Yi5jb20vQ29uc2Vuc3lzL2duYXJrLWNyeXB0by9ibG9iL21hc3Rlci9lY2MvYm4yNTQvZnIvZWxlbWVudC5nbyNMNDIKLy8gY197aSsxfSA9IEhzKG0gfHwgcl97aX0gKiBHICsgY197aX0gKiBLX3tpfSB8fCByX3tpfSpIcChLX3tpfSkgKyBjX3tpfSAqIEkpIG1vZCB8ZnJ8Ci8vIEBwYXJhbSBtc2cgLSBUaGUgbWVzc2FnZSB0byBiZSBzaWduZWQKLy8gQHBhcmFtIG5vbmNlIC0gVGhlIG5vbmNlLCBwYXJ0IG9mIHRoZSByaW5nIHNpZ25hdHVyZSBpdHNlbGYsIGFrYSBvbmUgb2YgdGhlIGZha2Ugc2VjcmV0IGtleXMKLy8gQHBhcmFtIGNQcmV2IC0gVGhlIHByZXZpb3VzIGNoYWxsZW5nZSwgb3IgdGhlIGJhc2UgY2hhbGxlbmdlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGxpbmsgKGluIHdoaWNoIGNhc2UgaXQgaXMgcGFydCBvZiB0aGUgcmluZyBzaWcpCi8vIEBwYXJhbSBwayAtIFRoZSBzcGVjaWZpYyBwdWJsaWMga2V5IGluIHRoZSByaW5nIChpbmRleGVkIGZyb20gdGhlIGFycmF5IG9mIHB1YmxpYyBrZXlzKQovLyBAcGFyYW0ga2V5SW1hZ2UgLSBUaGUga2V5IGltYWdlIG9mIHRoZSBzaWduZXIsIHJlcXVpcmVkIGZvciBsaW5rYWJpbHRpeSB0byBwcmV2ZW50IGRvdWJsZSBzcGVuZGluZwovLyBAcmV0dXJucyAtIHRoZSBjaGFsbGVuZ2UKY2hhbGxlbmdlOgoJcHJvdG8gNSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czoxODcKCS8vIGxlZnQgPSB0aGlzLnBvaW50QWRkKHRoaXMuc2NhbGFyTXVsdEJhc2Uobm9uY2UpLCB0aGlzLnNjYWxhck11bHQoY1ByZXYsIHBrKSkKCWZyYW1lX2RpZyAtNCAvLyBwazogYnl0ZXMKCWZyYW1lX2RpZyAtMyAvLyBjUHJldjogYnl0ZXMKCWNhbGxzdWIgc2NhbGFyTXVsdAoJZnJhbWVfZGlnIC0yIC8vIG5vbmNlOiBieXRlcwoJY2FsbHN1YiBzY2FsYXJNdWx0QmFzZQoJY2FsbHN1YiBwb2ludEFkZAoJZnJhbWVfYnVyeSAwIC8vIGxlZnQ6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czoxOTMKCS8vIHJpZ2h0ID0gdGhpcy5wb2ludEFkZCh0aGlzLnNjYWxhck11bHQobm9uY2UsIHRoaXMuaGFzaFBvaW50VG9Qb2ludChwaykpLCB0aGlzLnNjYWxhck11bHQoY1ByZXYsIGtleUltYWdlKSkKCWZyYW1lX2RpZyAtNSAvLyBrZXlJbWFnZTogYnl0ZXMKCWZyYW1lX2RpZyAtMyAvLyBjUHJldjogYnl0ZXMKCWNhbGxzdWIgc2NhbGFyTXVsdAoJZnJhbWVfZGlnIC00IC8vIHBrOiBieXRlcwoJY2FsbHN1YiBoYXNoUG9pbnRUb1BvaW50CglmcmFtZV9kaWcgLTIgLy8gbm9uY2U6IGJ5dGVzCgljYWxsc3ViIHNjYWxhck11bHQKCWNhbGxzdWIgcG9pbnRBZGQKCWZyYW1lX2J1cnkgMSAvLyByaWdodDogYnl0ZVtdCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjE5OQoJLy8gaCA9CgkvLyAgICAgICBidG9iaWdpbnQoc2hhMjU2KGNvbmNhdChjb25jYXQobXNnLCBsZWZ0KSwgcmlnaHQpKSkgJQoJLy8gICAgICAgYnRvYmlnaW50KGhleCgiMHgzMDY0NGU3MmUxMzFhMDI5Yjg1MDQ1YjY4MTgxNTg1ZDI4MzNlODQ4NzliOTcwOTE0M2UxZjU5M2YwMDAwMDAxIikpCglmcmFtZV9kaWcgLTEgLy8gbXNnOiBieXRlcwoJZnJhbWVfZGlnIDAgLy8gbGVmdDogYnl0ZVtdCgljb25jYXQKCWZyYW1lX2RpZyAxIC8vIHJpZ2h0OiBieXRlW10KCWNvbmNhdAoJc2hhMjU2CglieXRlIDB4MzA2NDRlNzJlMTMxYTAyOWI4NTA0NWI2ODE4MTU4NWQyODMzZTg0ODc5Yjk3MDkxNDNlMWY1OTNmMDAwMDAwMQoJYiUKCWZyYW1lX2J1cnkgMiAvLyBoOiBiaWdpbnQKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MjAyCgkvLyByZXR1cm4gcmF3Qnl0ZXMoaCk7CglmcmFtZV9kaWcgMiAvLyBoOiBiaWdpbnQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAyCglyZXRzdWIKCi8vIHB1YmxpY0NoYWxsZW5nZShieXRlW10sYnl0ZVtdLGJ5dGVbXSxieXRlW10sYnl0ZVtdKWJ5dGVbXQphYmlfcm91dGVfcHVibGljQ2hhbGxlbmdlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBrZXlJbWFnZTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglleHRyYWN0IDIgMAoKCS8vIHBrOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWV4dHJhY3QgMiAwCgoJLy8gY1ByZXY6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBub25jZTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIG1zZzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgcHVibGljQ2hhbGxlbmdlKGJ5dGVbXSxieXRlW10sYnl0ZVtdLGJ5dGVbXSxieXRlW10pYnl0ZVtdCgljYWxsc3ViIHB1YmxpY0NoYWxsZW5nZQoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBwdWJsaWNDaGFsbGVuZ2UobXNnOiBieXRlcywgbm9uY2U6IGJ5dGVzLCBjUHJldjogYnl0ZXMsIHBrOiBieXRlcywga2V5SW1hZ2U6IGJ5dGVzKTogYnl0ZXMKLy8KLy8gcHVibGljQ2hhbGxlbmdlCi8vIFB1YmxpYyB3cmFwcGVyIGFyb3VuZCB0aGUgY2hhbGxlbmdlIG1ldGhvZCwgYWxsb3dpbmcgaXQgdG8gYmUgdGVzdGVkIGRpcmVjdGx5LgovLyBAcGFyYW0gbXNnIC0gVGhlIG1lc3NhZ2UgdG8gYmUgc2lnbmVkCi8vIEBwYXJhbSBub25jZSAtIFRoZSBub25jZSwgcGFydCBvZiB0aGUgcmluZyBzaWduYXR1cmUgaXRzZWxmLCBha2Egb25lIG9mIHRoZSBmYWtlIHNlY3JldCBrZXlzCi8vIEBwYXJhbSBjUHJldiAtIFRoZSBwcmV2aW91cyBjaGFsbGVuZ2UsIG9yIHRoZSBiYXNlIGNoYWxsZW5nZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBsaW5rIChpbiB3aGljaCBjYXNlIGl0IGlzIHBhcnQgb2YgdGhlIHJpbmcgc2lnKQovLyBAcGFyYW0gcGsgLSBUaGUgc3BlY2lmaWMgcHVibGljIGtleSBpbiB0aGUgcmluZyAoaW5kZXhlZCBmcm9tIHRoZSBhcnJheSBvZiBwdWJsaWMga2V5cykKLy8gQHBhcmFtIGtleUltYWdlIC0gVGhlIGtleSBpbWFnZSBvZiB0aGUgc2lnbmVyLCByZXF1aXJlZCBmb3IgbGlua2FiaWx0aXkgdG8gcHJldmVudCBkb3VibGUgc3BlbmRpbmcKLy8gQHJldHVybnMgLSB0aGUgY29udGVudCBvZiB0aGUgcHJpdmF0ZUNoYWxsZW5nZSBjYWxsCnB1YmxpY0NoYWxsZW5nZToKCXByb3RvIDUgMQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czoyMTUKCS8vIHJldHVybiB0aGlzLmNoYWxsZW5nZShtc2csIG5vbmNlLCBjUHJldiwgcGssIGtleUltYWdlKTsKCWZyYW1lX2RpZyAtNSAvLyBrZXlJbWFnZTogYnl0ZXMKCWZyYW1lX2RpZyAtNCAvLyBwazogYnl0ZXMKCWZyYW1lX2RpZyAtMyAvLyBjUHJldjogYnl0ZXMKCWZyYW1lX2RpZyAtMiAvLyBub25jZTogYnl0ZXMKCWZyYW1lX2RpZyAtMSAvLyBtc2c6IGJ5dGVzCgljYWxsc3ViIGNoYWxsZW5nZQoJcmV0c3ViCgovLyBwdWJsaWNDaGFsbGVuZ2VMc2lnKGJ5dGVbXSxieXRlW10sYnl0ZVtdLGJ5dGVbXSxieXRlW10scGF5KWJ5dGVbXQphYmlfcm91dGVfcHVibGljQ2hhbGxlbmdlTHNpZzoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gbHNpZ1R4bjogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCgkvLyBrZXlJbWFnZTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglleHRyYWN0IDIgMAoKCS8vIHBrOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWV4dHJhY3QgMiAwCgoJLy8gY1ByZXY6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBub25jZTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIG1zZzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgcHVibGljQ2hhbGxlbmdlTHNpZyhieXRlW10sYnl0ZVtdLGJ5dGVbXSxieXRlW10sYnl0ZVtdLHBheSlieXRlW10KCWNhbGxzdWIgcHVibGljQ2hhbGxlbmdlTHNpZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBwdWJsaWNDaGFsbGVuZ2VMc2lnKG1zZzogYnl0ZXMsIG5vbmNlOiBieXRlcywgY1ByZXY6IGJ5dGVzLCBwazogYnl0ZXMsIGtleUltYWdlOiBieXRlcywgbHNpZ1R4bjogUGF5VHhuKTogYnl0ZXMKLy8KLy8gcHVibGljQ2hhbGxlbmdlCi8vIFB1YmxpYyB3cmFwcGVyIGFyb3VuZCB0aGUgY2hhbGxlbmdlIG1ldGhvZCwgYWxsb3dpbmcgaXQgdG8gYmUgdGVzdGVkIGRpcmVjdGx5LgovLyBAcGFyYW0gbXNnIC0gVGhlIG1lc3NhZ2UgdG8gYmUgc2lnbmVkCi8vIEBwYXJhbSBub25jZSAtIFRoZSBub25jZSwgcGFydCBvZiB0aGUgcmluZyBzaWduYXR1cmUgaXRzZWxmLCBha2Egb25lIG9mIHRoZSBmYWtlIHNlY3JldCBrZXlzCi8vIEBwYXJhbSBjUHJldiAtIFRoZSBwcmV2aW91cyBjaGFsbGVuZ2UsIG9yIHRoZSBiYXNlIGNoYWxsZW5nZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBsaW5rIChpbiB3aGljaCBjYXNlIGl0IGlzIHBhcnQgb2YgdGhlIHJpbmcgc2lnKQovLyBAcGFyYW0gcGsgLSBUaGUgc3BlY2lmaWMgcHVibGljIGtleSBpbiB0aGUgcmluZyAoaW5kZXhlZCBmcm9tIHRoZSBhcnJheSBvZiBwdWJsaWMga2V5cykKLy8gQHBhcmFtIGtleUltYWdlIC0gVGhlIGtleSBpbWFnZSBvZiB0aGUgc2lnbmVyLCByZXF1aXJlZCBmb3IgbGlua2FiaWx0aXkgdG8gcHJldmVudCBkb3VibGUgc3BlbmRpbmcKLy8gQHJldHVybnMgLSB0aGUgY29udGVudCBvZiB0aGUgcHJpdmF0ZUNoYWxsZW5nZSBjYWxsCnB1YmxpY0NoYWxsZW5nZUxzaWc6Cglwcm90byA2IDEKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MjI4CgkvLyByZXR1cm4gdGhpcy5jaGFsbGVuZ2UobXNnLCBub25jZSwgY1ByZXYsIHBrLCBrZXlJbWFnZSk7CglmcmFtZV9kaWcgLTUgLy8ga2V5SW1hZ2U6IGJ5dGVzCglmcmFtZV9kaWcgLTQgLy8gcGs6IGJ5dGVzCglmcmFtZV9kaWcgLTMgLy8gY1ByZXY6IGJ5dGVzCglmcmFtZV9kaWcgLTIgLy8gbm9uY2U6IGJ5dGVzCglmcmFtZV9kaWcgLTEgLy8gbXNnOiBieXRlcwoJY2FsbHN1YiBjaGFsbGVuZ2UKCXJldHN1YgoKLy8gZGVwb3NpdChwYXksYnl0ZVtdKXVpbnQ2NFtdCmFiaV9yb3V0ZV9kZXBvc2l0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBwazogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGRlcG9zaXRUeG46IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBkZXBvc2l0KHBheSxieXRlW10pdWludDY0W10KCWNhbGxzdWIgZGVwb3NpdAoJZHVwCglsZW4KCWludCA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZGVwb3NpdChkZXBvc2l0VHhuOiBQYXlUeG4sIHBrOiBieXRlcyk6IHVpbnQ2NFtdCi8vCi8vIGRlcG9zaXQKLy8gRGVwb3NpdCBmdW5kcyArIHB1YmxpYyBrZXkgaW50byB0aGUgY29udHJhY3QKLy8gQHBhcmFtIHBrIC0gVGhlIHB1YmxpYyBrZXkgdG8gZGVwb3NpdAovLyBUT0RPOiBBZGQgY3VzdG9tIEVkRFNBIHRvIGNoZWNrIHRoYXQgdGhlIGRlcG9zaXRvciBrbm93cyB0aGUgc2VjcmV0IGtleS4gVXNlZnVsIHRvIHByZXZlbnQgcm9ndWUga2V5IGF0dGFjaywgYWRkaW5nIHRoZSBuZWdhdGl2ZSBvZiBhbm90aGVyIHBrLgovLyBAcmV0dXJucyAtIHRoZSBudW1iZXIgaWQgb2YgdGhlIHB1YmxpYyBrZXksIGlmIHN1Y2Nlc3NmdWwuIGZhaWxzIGlmIHVuc3VjY2Vzc2Z1bC4KZGVwb3NpdDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXAKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MjM5CgkvLyBhc3NlcnQodGhpcy52YWxpZFBvaW50KHBrKSkKCWZyYW1lX2RpZyAtMiAvLyBwazogYnl0ZXMKCWNhbGxzdWIgdmFsaWRQb2ludAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjI0MAoJLy8gYXNzZXJ0KCF0aGlzLmhhc2hGaWx0ZXIocGspLmV4aXN0cykKCWZyYW1lX2RpZyAtMiAvLyBwazogYnl0ZXMKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjI0MgoJLy8gdmVyaWZ5VHhuKGRlcG9zaXRUeG4sIHsKCS8vICAgICAgIC8vIEVuc3VyZSB0aGUgZGVwb3NpdG9yIGlzIGZ1bmRpbmcgdGhlIHJpZ2h0IGFtb3VudAoJLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICBhbW91bnQ6IHRoaXMuZGVub21pbmF0aW9uLnZhbHVlLAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBkZXBvc2l0VHhuOiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBkZXBvc2l0VHhuOiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJYnl0ZSAweDY0NjU2ZTZmNmQ2OTZlNjE3NDY5NmY2ZSAvLyAiZGVub21pbmF0aW9uIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MjQ5CgkvLyBib3hJZCA9IHRoaXMucGtJbmRleC52YWx1ZSAvIE1BWF9QS19CT1hfUEtfTlVNQkVSCglieXRlIDB4NzA2YjQ5NmU2NDY1NzggLy8gInBrSW5kZXgiCglhcHBfZ2xvYmFsX2dldAoJaW50IDQ5NgoJLwoJZnJhbWVfYnVyeSAwIC8vIGJveElkOiB1aW50NjQKCgkvLyBpZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MjYyCgkvLyAhdGhpcy5xdWlja0FjY2Vzc1BLQm94ZXMoYm94SWQpLmV4aXN0cwoJZnJhbWVfZGlnIDAgLy8gYm94SWQ6IHVpbnQ2NAoJaXRvYgoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiBpZjBfZW5kCgoJLy8gaWYwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czoyNjMKCS8vIHRoaXMucXVpY2tBY2Nlc3NQS0JveGVzKGJveElkKS5jcmVhdGUoTUFYX1BLX0JPWF9TSVpFKQoJZnJhbWVfZGlnIDAgLy8gYm94SWQ6IHVpbnQ2NAoJaXRvYgoJaW50IDMxNzQ0Cglib3hfY3JlYXRlCglwb3AKCmlmMF9lbmQ6CgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MjY3CgkvLyB0aGlzLnF1aWNrQWNjZXNzUEtCb3hlcyhib3hJZCkucmVwbGFjZSgodGhpcy5wa0luZGV4LnZhbHVlICUgTUFYX1BLX0JPWF9QS19OVU1CRVIpICogQ1VSVkVfUE9JTlRfU0laRSwgcGspCglmcmFtZV9kaWcgMCAvLyBib3hJZDogdWludDY0CglpdG9iCglieXRlIDB4NzA2YjQ5NmU2NDY1NzggLy8gInBrSW5kZXgiCglhcHBfZ2xvYmFsX2dldAoJaW50IDQ5NgoJJQoJaW50IDY0CgkqCglmcmFtZV9kaWcgLTIgLy8gcGs6IGJ5dGVzCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czoyNzAKCS8vIHRoaXMuaGFzaEZpbHRlcihwaykuY3JlYXRlKDApCglmcmFtZV9kaWcgLTIgLy8gcGs6IGJ5dGVzCglpbnQgMAoJYm94X2NyZWF0ZQoJcG9wCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjI3MgoJLy8gaWR4ID0gdGhpcy5wa0luZGV4LnZhbHVlCglieXRlIDB4NzA2YjQ5NmU2NDY1NzggLy8gInBrSW5kZXgiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSAxIC8vIGlkeDogdWludDY0CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjI3NQoJLy8gdGhpcy5wa0luZGV4LnZhbHVlID0gdGhpcy5wa0luZGV4LnZhbHVlICsgMQoJYnl0ZSAweDcwNmI0OTZlNjQ2NTc4IC8vICJwa0luZGV4IgoJZHVwCglhcHBfZ2xvYmFsX2dldAoJaW50IDEKCSsKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjI3NwoJLy8gcmV0dXJuIFtpZHgsIGJveElkXTsKCWZyYW1lX2RpZyAxIC8vIGlkeDogdWludDY0CglpdG9iCglmcmFtZV9kaWcgMCAvLyBib3hJZDogdWludDY0CglpdG9iCgljb25jYXQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxCglyZXRzdWIKCi8vIGluaXRXaXRoZHJhd2FsU2Vzc2lvbihwYXksYnl0ZVtdLGJ5dGVbXSlieXRlWzMyXQphYmlfcm91dGVfaW5pdFdpdGhkcmF3YWxTZXNzaW9uOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBpbml0aWFsQ2hhbGxlbmdlOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gbXNnOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gbWJickRlcG9zaXRUeG46IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBpbml0V2l0aGRyYXdhbFNlc3Npb24ocGF5LGJ5dGVbXSxieXRlW10pYnl0ZVszMl0KCWNhbGxzdWIgaW5pdFdpdGhkcmF3YWxTZXNzaW9uCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gaW5pdFdpdGhkcmF3YWxTZXNzaW9uKG1iYnJEZXBvc2l0VHhuOiBQYXlUeG4sIG1zZzogYnl0ZXMsIGluaXRpYWxDaGFsbGVuZ2U6IGJ5dGVzKTogYnl0ZXMzMgovLwovLyBpbml0V2l0aGRyYXdhbAovLyBDcmVhdGVzIGEgYm94IHJlcHJlc2VudGluZyBhICJ3aXRoZHJhd2FsIHNlc3Npb24iLgovLyBPZiBrZXkgaW1wb3J0YW5jZSBpcyB0aGUgc2lnbmVkIG1lc3NhZ2Ugc3RyaW5nLCB3aGljaCBtdXN0IGNvbnRhaW4gdGhlIGZvbGxvd2luZzoKLy8gUmluZyBTaXplIC0gQ2hvc2VuIG51bWJlciBvZiBQS3MsIGkuZS4gc2l6ZSBvZiBhbm9ueW1pdHkgc2V0Ci8vIEtleSBJbWFnZSAtIFRoZSBrZXlpbWFnZSwgdGhlIG9uZSB0aGluZyB0aGF0IGlzIHVuaXF1ZSBmb3IgYSB3aXRoZHJhd2FsCi8vIEFwcCBJZCAtIFRoZSBpZCBvZiB0aGUgc21hcnQgY29udHJhY3QgYXBwCi8vIE5vbWluYWwgYW1vdW50IC0gVGhlIGRlbm9taW5hdGlvbiBvZiB0aGUgY29udHJhY3QsIHdoYXQgd2FzIGRlcG9zaXRlZCBvcmlnaW5hbGx5Ci8vIEFTQSBJRCAtIENsYXJpZmllcyB0aGUgQVNBIElELiAoUGxhaW4gQWxnbyBoYXMgSUQgMCwgInRoZSBkZWZhdWx0IiBhc3NldCBvZiBBbGdvcmFuZCkKLy8gV2l0aGRyYXdhbCBBZGRyZXNzIC0gQWRkcmVzcyBvZiB0aGUgZmluYWwgcmVjaXBpZW50IG9mIHRoZSBmdW5kcwovLyBSZWxheWVyIEFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSByZWxheWVyLCBmYWNpbGl0YXRpbmcgdGhlIHdpdGhkcmF3YWwgKGNvdWxkIGJlIHNhbWUgYXMgd2l0aGRyYXdhbCBhZGRyZXNzKQovLyBSZWxheWVyIEZlZSAtIFRoZSBmZWUgdGhlIHJlbGF5ZXIgY2hhcmdlcyBmb3IgZmFjaWxpdGF0aW5nIHRoZSB3aXRoZHJhd2FsIChjb3VsZCBiZSAwKQovLyBUaGUgaGFzaCBvZiB0aGUgbWVzc2FnZSBiZWNvbWVzIHRoZSBpZCBvZiB0aGUgd2l0aGRyYXdhbCBzZXNzaW9uJ3MgYm94LgovLyBAcGFyYW0gbWJickRlcG9zaXRUeG4gLSBUaGUgdHJhbnNhY3Rpb24gdGhhdCBkZXBvc2l0ZWQgdGhlIE1CQlIKLy8gQHBhcmFtIG1zZyAtIFNpZ25lZCBtZXNzYWdlCi8vIEBwYXJhbSBpbml0aWFsQ2hhbGxlbmdlIC0gVGhlIGluaXRpYWwgY2hhbGxlbmdlLCB3aGljaCBuZWVkcyB0byBiZSByZS1jcmVhdGVkIHRvIHZlcmlmeSB0aGUgcmluZyBzaWduYXR1cmUKLy8gQHJldHVybnMgLSB0aGUgaWQgb2YgdGhlIHdpdGhkcmF3YWwgc2Vzc2lvbiBib3gKaW5pdFdpdGhkcmF3YWxTZXNzaW9uOgoJcHJvdG8gMyAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MzAxCgkvLyBpZCA9IHNoYTI1Nihtc2cpCglmcmFtZV9kaWcgLTIgLy8gbXNnOiBieXRlcwoJc2hhMjU2CglmcmFtZV9idXJ5IDAgLy8gaWQ6IGJ5dGVbMzJdCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjMwMgoJLy8gdGhpcy5zZXNzaW9uc0JveGVzKGlkKS5jcmVhdGUobGVuKG1zZykgKyAyICogbGVuKGluaXRpYWxDaGFsbGVuZ2UpKQoJZnJhbWVfZGlnIDAgLy8gaWQ6IGJ5dGVbMzJdCglmcmFtZV9kaWcgLTIgLy8gbXNnOiBieXRlcwoJbGVuCglpbnQgMgoJZnJhbWVfZGlnIC0zIC8vIGluaXRpYWxDaGFsbGVuZ2U6IGJ5dGVzCglsZW4KCSoKCSsKCWJveF9jcmVhdGUKCXBvcAoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czozMDgKCS8vIHJldHVybiBpZDsKCWZyYW1lX2RpZyAwIC8vIGlkOiBieXRlWzMyXQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBjcmVhdGVVcGxvYWRQcmVjb21wdXRlZENoYWxsZW5nZXNCb3gocGF5LGJ5dGVbXSx1aW50NjQsdWludDY0KWJ5dGVbMzJdCmFiaV9yb3V0ZV9jcmVhdGVVcGxvYWRQcmVjb21wdXRlZENoYWxsZW5nZXNCb3g6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGJveFNpemU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGJveEluZGV4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBtc2c6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBtYmJyRGVwb3NpdFR4bjogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGNyZWF0ZVVwbG9hZFByZWNvbXB1dGVkQ2hhbGxlbmdlc0JveChwYXksYnl0ZVtdLHVpbnQ2NCx1aW50NjQpYnl0ZVszMl0KCWNhbGxzdWIgY3JlYXRlVXBsb2FkUHJlY29tcHV0ZWRDaGFsbGVuZ2VzQm94Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gY3JlYXRlVXBsb2FkUHJlY29tcHV0ZWRDaGFsbGVuZ2VzQm94KG1iYnJEZXBvc2l0VHhuOiBQYXlUeG4sIG1zZzogYnl0ZXMsIGJveEluZGV4OiB1aW50NjQsIGJveFNpemU6IHVpbnQ2NCk6IGJ5dGVzMzIKLy8KLy8gVE9ETzogZGVzdHJveVdpdGhkcmF3YWxTZXNzaW9uLCBJRiBTRVNTSU9OIExPQ0tFRAovLyBjcmVhdGVVcGxvYWRQcmVjb21wdXRlZENoYWxsZW5nZXNCb3gKLy8gQ3JlYXRlcyBhIGJveCB0aGF0IHdpbGwgYmUgdXNlZCB0byB1cGxvYWQgcHJlY29tcHV0ZWQgY2hhbGxlbmdlcyBpbnRvLgovLyBAcGFyYW0gbXNnIC0gTXNnLCBmdW5jdGlvbmluZyBhcyB0aGUgaWQgZm9yIHRoZSB3aXRoZHJhd2FsIHNlc3Npb24KLy8gQHBhcmFtIGJveEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBwcmVjb21wdXRlZCBjaGFsbGVuZ2UgYm94LCBpbmNyZW1lbnRpbmcgd2l0aCBlYWNoIGNodW5rIG9mIGRhdGUuCi8vIEBwYXJhbSBib3hTaXplIC0gVGhlIHNpemUgb2YgdGhlIHByZWNvbXB1dGVkIGNoYWxsZW5nZSBib3gKLy8gQHJldHVybnMgLSB0aGUgaWQgb2YgdGhlIHByZWNvbXB1dGVkIGNoYWxsZW5nZSBib3gKY3JlYXRlVXBsb2FkUHJlY29tcHV0ZWRDaGFsbGVuZ2VzQm94OgoJcHJvdG8gNCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MzI0CgkvLyBib3hJZCA9IHNoYTI1Nihjb25jYXQoY29uY2F0KHNoYTI1Nihtc2cpLCAicHJlY29tcHV0ZWRDaGFsbGVuZ2VzIiksIGl0b2IoYm94SW5kZXgpKSkKCWZyYW1lX2RpZyAtMiAvLyBtc2c6IGJ5dGVzCglzaGEyNTYKCWJ5dGUgMHg3MDcyNjU2MzZmNmQ3MDc1NzQ2NTY0NDM2ODYxNmM2YzY1NmU2NzY1NzMgLy8gInByZWNvbXB1dGVkQ2hhbGxlbmdlcyIKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIGJveEluZGV4OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJc2hhMjU2CglmcmFtZV9idXJ5IDAgLy8gYm94SWQ6IGJ5dGVbMzJdCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjMyNQoJLy8gdGhpcy5wcmVjb21wdXRlZENoYWxsZW5nZXNCb3hlcyhib3hJZCkuY3JlYXRlKGJveFNpemUpCglmcmFtZV9kaWcgMCAvLyBib3hJZDogYnl0ZVszMl0KCWZyYW1lX2RpZyAtNCAvLyBib3hTaXplOiB1aW50NjQKCWJveF9jcmVhdGUKCXBvcAoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czozMjYKCS8vIHJldHVybiBib3hJZDsKCWZyYW1lX2RpZyAwIC8vIGJveElkOiBieXRlWzMyXQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyB1cGxvYWRQcmVjb21wdXRlZENoYWxsZW5nZXMoYnl0ZVtdLHVpbnQ2NCxieXRlW10pYnl0ZVszMl0KYWJpX3JvdXRlX3VwbG9hZFByZWNvbXB1dGVkQ2hhbGxlbmdlczoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gcHJlY29tcHV0ZWRDaGFsbGVuZ2VzOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gYm94SW5kZXg6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIG1zZzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdXBsb2FkUHJlY29tcHV0ZWRDaGFsbGVuZ2VzKGJ5dGVbXSx1aW50NjQsYnl0ZVtdKWJ5dGVbMzJdCgljYWxsc3ViIHVwbG9hZFByZWNvbXB1dGVkQ2hhbGxlbmdlcwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIHVwbG9hZFByZWNvbXB1dGVkQ2hhbGxlbmdlcyhtc2c6IGJ5dGVzLCBib3hJbmRleDogdWludDY0LCBwcmVjb21wdXRlZENoYWxsZW5nZXM6IGJ5dGVzKTogYnl0ZXMzMgovLwovLyB1cGxvYWRQcmVjb21wdXRlZENoYWxsZW5nZXMKLy8gQ3JlYXRlcyBhIGJveCBhbmQgdXBsb2FkcyB0aGUgcHJlY29tcHV0ZWQgY2hhbGxlbmdlcyBpbnRvIGl0LgovLyBAcGFyYW0gbXNnIC0gTXNnLCBmdW5jdGlvbmluZyBhcyB0aGUgaWQgZm9yIHRoZSB3aXRoZHJhd2FsIHNlc3Npb24KLy8gQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBwcmVjb21wdXRlZCBjaGFsbGVuZ2UgYm94LCBpbmNyZW1lbnRpbmcgd2l0aCBlYWNoIGNodW5rIG9mIGRhdGUuCi8vIEBwYXJhbSBwcmVjb21wdXRlZENoYWxsZW5nZXMgLSBUaGUgcHJlY29tcHV0ZWQgY2hhbGxlbmdlcwovLyBAcmV0dXJucyAtIHRoZSBpZCBvZiB0aGUgcHJlY29tcHV0ZWQgY2hhbGxlbmdlIGJveAp1cGxvYWRQcmVjb21wdXRlZENoYWxsZW5nZXM6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czozMzkKCS8vIGJveElkID0gc2hhMjU2KGNvbmNhdChjb25jYXQoc2hhMjU2KG1zZyksICJwcmVjb21wdXRlZENoYWxsZW5nZXMiKSwgaXRvYihib3hJbmRleCkpKQoJZnJhbWVfZGlnIC0xIC8vIG1zZzogYnl0ZXMKCXNoYTI1NgoJYnl0ZSAweDcwNzI2NTYzNmY2ZDcwNzU3NDY1NjQ0MzY4NjE2YzZjNjU2ZTY3NjU3MyAvLyAicHJlY29tcHV0ZWRDaGFsbGVuZ2VzIgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglzaGEyNTYKCWZyYW1lX2J1cnkgMCAvLyBib3hJZDogYnl0ZVszMl0KCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MzQwCgkvLyB0aGlzLnByZWNvbXB1dGVkQ2hhbGxlbmdlc0JveGVzKGJveElkKS5yZXBsYWNlKDAsIHByZWNvbXB1dGVkQ2hhbGxlbmdlcykKCWZyYW1lX2RpZyAwIC8vIGJveElkOiBieXRlWzMyXQoJaW50IDAKCWZyYW1lX2RpZyAtMyAvLyBwcmVjb21wdXRlZENoYWxsZW5nZXM6IGJ5dGVzCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czozNDEKCS8vIHJldHVybiBib3hJZDsKCWZyYW1lX2RpZyAwIC8vIGJveElkOiBieXRlWzMyXQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBjcmVhdGVJbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94KHBheSxieXRlW10sdWludDY0LHVpbnQ2NClieXRlWzMyXQphYmlfcm91dGVfY3JlYXRlSW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gYm94U2l6ZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYm94SW5kZXg6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIG1zZzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIG1iYnJEZXBvc2l0VHhuOiBwYXkKCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgY3JlYXRlSW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveChwYXksYnl0ZVtdLHVpbnQ2NCx1aW50NjQpYnl0ZVszMl0KCWNhbGxzdWIgY3JlYXRlSW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveAoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNyZWF0ZUludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3gobWJickRlcG9zaXRUeG46IFBheVR4biwgbXNnOiBieXRlcywgYm94SW5kZXg6IHVpbnQ2NCwgYm94U2l6ZTogdWludDY0KTogYnl0ZXMzMgovLwovLyBjcmVhdGVJbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94Ci8vIENyZWF0ZXMgYSBib3ggdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29udGFpbiBpbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94LgovLyBTaG91bGQgZXZlbnR1YWxseSBiZSBhIG1pcnJvciBpbWFnZSBvZiB0aGUgY29ycmVzcG9uZGluZyB1cGxvYWRQcmVjb21wdXRlZENoYWxsZW5nZXNCb3guCi8vIEBwYXJhbSBtc2cgLSBNc2csIGZ1bmN0aW9uaW5nIGFzIHRoZSBpZCBmb3IgdGhlIHdpdGhkcmF3YWwgc2Vzc2lvbgovLyBAcGFyYW0gYm94SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHByZWNvbXB1dGVkIGNoYWxsZW5nZSBib3gsIGluY3JlbWVudGluZyB3aXRoIGVhY2ggY2h1bmsgb2YgZGF0ZS4KLy8gQHBhcmFtIGJveFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgcHJlY29tcHV0ZWQgY2hhbGxlbmdlIGJveAovLyBAcmV0dXJucyAtIHRoZSBpZCBvZiB0aGUgcHJlY29tcHV0ZWQgY2hhbGxlbmdlIGJveApjcmVhdGVJbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94OgoJcHJvdG8gNCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MzU2CgkvLyBib3hJZCA9IHNoYTI1Nihjb25jYXQoY29uY2F0KHNoYTI1Nihtc2cpLCAiaW50ZXJtZWRpYXRlQ2hhbGxlbmdlcyIpLCBpdG9iKGJveEluZGV4KSkpCglmcmFtZV9kaWcgLTIgLy8gbXNnOiBieXRlcwoJc2hhMjU2CglieXRlIDB4Njk2ZTc0NjU3MjZkNjU2NDY5NjE3NDY1NDM2ODYxNmM2YzY1NmU2NzY1NzMgLy8gImludGVybWVkaWF0ZUNoYWxsZW5nZXMiCgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyBib3hJbmRleDogdWludDY0CglpdG9iCgljb25jYXQKCXNoYTI1NgoJZnJhbWVfYnVyeSAwIC8vIGJveElkOiBieXRlWzMyXQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czozNTcKCS8vIHRoaXMucHJlY29tcHV0ZWRDaGFsbGVuZ2VzQm94ZXMoYm94SWQpLmNyZWF0ZShib3hTaXplKQoJZnJhbWVfZGlnIDAgLy8gYm94SWQ6IGJ5dGVbMzJdCglmcmFtZV9kaWcgLTQgLy8gYm94U2l6ZTogdWludDY0Cglib3hfY3JlYXRlCglwb3AKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MzU4CgkvLyByZXR1cm4gYm94SWQ7CglmcmFtZV9kaWcgMCAvLyBib3hJZDogYnl0ZVszMl0KCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gY29tcHV0ZUluZGl2aWR1YWxDaGFsbGVuZ2UoYnl0ZVtdLGJ5dGVbXSx1aW50NjQsYnl0ZVtdLHVpbnQ2NCx1aW50NjQpKGJ5dGVbMzJdLHVpbnQ2NCkKYWJpX3JvdXRlX2NvbXB1dGVJbmRpdmlkdWFsQ2hhbGxlbmdlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBjUHJldk9mZnNldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglidG9pCgoJLy8gY1ByZXZCb3hJbmRleDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8ga2V5SW1hZ2U6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZXh0cmFjdCAyIDAKCgkvLyBwa0luZGV4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBub25jZTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIG1zZzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgY29tcHV0ZUluZGl2aWR1YWxDaGFsbGVuZ2UoYnl0ZVtdLGJ5dGVbXSx1aW50NjQsYnl0ZVtdLHVpbnQ2NCx1aW50NjQpKGJ5dGVbMzJdLHVpbnQ2NCkKCWNhbGxzdWIgY29tcHV0ZUluZGl2aWR1YWxDaGFsbGVuZ2UKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBjb21wdXRlSW5kaXZpZHVhbENoYWxsZW5nZShtc2c6IGJ5dGVzLCBub25jZTogYnl0ZXMsIHBrSW5kZXg6IHVpbnQ2NCwga2V5SW1hZ2U6IGJ5dGVzLCBjUHJldkJveEluZGV4OiB1aW50NjQsIGNQcmV2T2Zmc2V0OiB1aW50NjQpOiBbYnl0ZXMzMiwgdWludDY0XQovLwovLyBjb21wdXRlSW5kaXZpZHVhbENoYWxsZW5nZQovLyBDb21wdXRlcyBhbiBpbmRpdmlkdWFsIGNoYWxsZW5nZS4KLy8gTm90ZSB0aGF0IHRoZSBwcmV2aW91cyBjaGFsbGVuZ2UgaXMgbG9hZGVkIHNwZWNpZmljYWxseSBmcm9tIHRoZSBwcmVjb21wdXRlZCBjaGFsbGVuZ2VzIGJveC4KLy8gV2hpbGUgdGhlIGNhbGN1bGF0ZWQgY2hhbGxlbmdlIGlzIGxvYWRlZCBpbnRvIHRoZSBpbnRlcm1lZGlhdGUgY2hhbGxlbmdlcyBib3guCi8vIEF0IHRoZSBlbmQgd2Ugd2lsbCBjb21wYXJlIGlmIHRoZSB0d28gYm94ZXMgYXJlIHRoZSBzYW1lLCBhbmQgb2YgY291cnNlIHRoYXQgdGhlIGxhc3QgY2hhbGxlbmdlIGlzIHRoZSBzYW1lIGFzIHRoZSBpbml0aWFsIGNoYWxsZW5nZS4KLy8gQnkgbG9hZGluZyBzcGVjaWZpY2FsbHkgZnJvbSB0aGUgcHJlY29tcHV0ZWQgY2hhbGxlbmdlcyBib3ggd2UgY2FuIHZlcmlmeSBpbiBwYXJhbGxlbGwuCi8vIFRoZSBvZGRzIG9mIGJlaW5nIGFibGUgdG8gYXJyaXZlIGF0IHRoZSBzYW1lIGluaXRpYWwgY2hhbGxlbmdlIGluIHRoZSBsYXN0IGNoYWxsZW5nZSBpcyBhc3Ryb25vbWljYWxseSBsb3cgVU5MRVNTIGl0IGlzIGEgdmFsaWQgcmluZyBzaWduYXR1cmUuCi8vIFB1YmxpYyBrZXlzIGFyZSBvZiBjb3Vyc2UgbG9hZGVkIGZyb20gdGhlIGNvbnRyYWN0IHN0b3JhZ2UuCi8vIEBwYXJhbSBtc2cgLSBUaGUgbWVzc2FnZSB0byBiZSBzaWduZWQKLy8gQHBhcmFtIG5vbmNlIC0gVGhlIG5vbmNlLCBwYXJ0IG9mIHRoZSByaW5nIHNpZ25hdHVyZSBpdHNlbGYsIGFrYSBvbmUgb2YgdGhlIGZha2Ugc2VjcmV0IGtleXMKLy8gQHBhcmFtIHBrSW5kZXgtIFRoZSBpbmRleCBudW1iZXIgb2YgdGhlIHB1YmxpYyBrZXkgaW4gdGhlIHNtYXJ0IGNvbnRyYWN0IHN0b3JhZ2UKLy8gQHBhcmFtIGtleUltYWdlIC0gVGhlIGtleSBpbWFnZSBvZiB0aGUgc2lnbmVyLCByZXF1aXJlZCBmb3IgbGlua2FiaWx0aXkgdG8gcHJldmVudCBkb3VibGUgc3BlbmRpbmcKLy8gQHBhcmFtIGNQcmV2SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIGNoYWxsZW5nZSwgYWxsb3dpbmcgaXQgdG8gYmUgbG9hZGVkIGZyb20gdGhlIGxvYWRlZCBwcmVjb21wdXRlZCBjaGFsbGVuZ2VzIGJveAovLyBAcmV0dXJucyAtIC4uLgpjb21wdXRlSW5kaXZpZHVhbENoYWxsZW5nZToKCXByb3RvIDYgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDkKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6Mzg5CgkvLyBwa0JveElkID0gcGtJbmRleCAvIE1BWF9QS19CT1hfUEtfTlVNQkVSCglmcmFtZV9kaWcgLTMgLy8gcGtJbmRleDogdWludDY0CglpbnQgNDk2CgkvCglmcmFtZV9idXJ5IDAgLy8gcGtCb3hJZDogdWludDY0CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjM5MAoJLy8gcGtPZmZzZXQgPSAocGtJbmRleCAlIE1BWF9QS19CT1hfUEtfTlVNQkVSKSAqIENVUlZFX1BPSU5UX1NJWkUKCWZyYW1lX2RpZyAtMyAvLyBwa0luZGV4OiB1aW50NjQKCWludCA0OTYKCSUKCWludCA2NAoJKgoJZnJhbWVfYnVyeSAxIC8vIHBrT2Zmc2V0OiB1aW50NjQKCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MzkxCgkvLyBwayA9IHRoaXMucXVpY2tBY2Nlc3NQS0JveGVzKHBrQm94SWQpLmV4dHJhY3QocGtPZmZzZXQsIHBrT2Zmc2V0ICsgQ1VSVkVfUE9JTlRfU0laRSkKCWZyYW1lX2RpZyAwIC8vIHBrQm94SWQ6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIDEgLy8gcGtPZmZzZXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gcGtPZmZzZXQ6IHVpbnQ2NAoJaW50IDY0CgkrCglib3hfZXh0cmFjdAoJZnJhbWVfYnVyeSAyIC8vIHBrOiBieXRlW10KCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6MzkzCgkvLyBjUHJldkJveElkID0gc2hhMjU2KGNvbmNhdChjb25jYXQoc2hhMjU2KG1zZyksICJwcmVjb21wdXRlZENoYWxsZW5nZXMiKSwgaXRvYihjUHJldkJveEluZGV4KSkpCglmcmFtZV9kaWcgLTEgLy8gbXNnOiBieXRlcwoJc2hhMjU2CglieXRlIDB4NzA3MjY1NjM2ZjZkNzA3NTc0NjU2NDQzNjg2MTZjNmM2NTZlNjc2NTczIC8vICJwcmVjb21wdXRlZENoYWxsZW5nZXMiCgljb25jYXQKCWZyYW1lX2RpZyAtNSAvLyBjUHJldkJveEluZGV4OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJc2hhMjU2CglmcmFtZV9idXJ5IDMgLy8gY1ByZXZCb3hJZDogYnl0ZVszMl0KCgkvLyBjb250cmFjdHMvbWFoYmVyLmFsZ28udHM6Mzk0CgkvLyBjUHJldiA9IHRoaXMucHJlY29tcHV0ZWRDaGFsbGVuZ2VzQm94ZXMoY1ByZXZCb3hJZCkuZXh0cmFjdChjUHJldk9mZnNldCwgY1ByZXZPZmZzZXQgKyBDSEFMTEVOR0VfU0laRSkKCWZyYW1lX2RpZyAzIC8vIGNQcmV2Qm94SWQ6IGJ5dGVbMzJdCglmcmFtZV9kaWcgLTYgLy8gY1ByZXZPZmZzZXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC02IC8vIGNQcmV2T2Zmc2V0OiB1aW50NjQKCWludCAzMgoJKwoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgNCAvLyBjUHJldjogYnl0ZVtdCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjM5NgoJLy8gY29tcHV0ZWRDaGFsbGVuZ2UgPSB0aGlzLmNoYWxsZW5nZShtc2csIG5vbmNlLCBjUHJldiwgcGssIGtleUltYWdlKQoJZnJhbWVfZGlnIC00IC8vIGtleUltYWdlOiBieXRlcwoJZnJhbWVfZGlnIDIgLy8gcGs6IGJ5dGVbXQoJZnJhbWVfZGlnIDQgLy8gY1ByZXY6IGJ5dGVbXQoJZnJhbWVfZGlnIC0yIC8vIG5vbmNlOiBieXRlcwoJZnJhbWVfZGlnIC0xIC8vIG1zZzogYnl0ZXMKCWNhbGxzdWIgY2hhbGxlbmdlCglmcmFtZV9idXJ5IDUgLy8gY29tcHV0ZWRDaGFsbGVuZ2U6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czozOTgKCS8vIGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hJbmRleCA9IGNQcmV2Qm94SW5kZXgKCWZyYW1lX2RpZyAtNSAvLyBjUHJldkJveEluZGV4OiB1aW50NjQKCWZyYW1lX2J1cnkgNiAvLyBpbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94SW5kZXg6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czozOTkKCS8vIGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hPZmZzZXQgPSBjUHJldk9mZnNldCArIENIQUxMRU5HRV9TSVpFCglmcmFtZV9kaWcgLTYgLy8gY1ByZXZPZmZzZXQ6IHVpbnQ2NAoJaW50IDMyCgkrCglmcmFtZV9idXJ5IDcgLy8gaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveE9mZnNldDogdWludDY0CgoJLy8gaWYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjQwMAoJLy8gaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveE9mZnNldCA9PT0gTUFYX0JPWF9CWVRFUwoJZnJhbWVfZGlnIDcgLy8gaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveE9mZnNldDogdWludDY0CglpbnQgMzI3NjgKCT09CglieiBpZjFfZW5kCgoJLy8gaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czo0MDIKCS8vIGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hJbmRleCA9IGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hJbmRleCArIDEKCWZyYW1lX2RpZyA2IC8vIGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hJbmRleDogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSA2IC8vIGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hJbmRleDogdWludDY0CgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjQwMwoJLy8gaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveE9mZnNldCA9IDAKCWludCAwCglmcmFtZV9idXJ5IDcgLy8gaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveE9mZnNldDogdWludDY0CgppZjFfZW5kOgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjQxMQoJLy8gaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveElkID0gc2hhMjU2KAoJLy8gICAgICAgY29uY2F0KGNvbmNhdChzaGEyNTYobXNnKSwgInByZWNvbXB1dGVkQ2hhbGxlbmdlcyIpLCBpdG9iKGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hJbmRleCkpCgkvLyAgICAgKQoJZnJhbWVfZGlnIC0xIC8vIG1zZzogYnl0ZXMKCXNoYTI1NgoJYnl0ZSAweDcwNzI2NTYzNmY2ZDcwNzU3NDY1NjQ0MzY4NjE2YzZjNjU2ZTY3NjU3MyAvLyAicHJlY29tcHV0ZWRDaGFsbGVuZ2VzIgoJY29uY2F0CglmcmFtZV9kaWcgNiAvLyBpbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94SW5kZXg6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglzaGEyNTYKCWZyYW1lX2J1cnkgOCAvLyBpbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94SWQ6IGJ5dGVbMzJdCgoJLy8gY29udHJhY3RzL21haGJlci5hbGdvLnRzOjQxNAoJLy8gdGhpcy5pbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94ZXMoaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveElkKS5yZXBsYWNlKAoJLy8gICAgICAgaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveE9mZnNldCwKCS8vICAgICAgIGNvbXB1dGVkQ2hhbGxlbmdlCgkvLyAgICAgKQoJZnJhbWVfZGlnIDggLy8gaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveElkOiBieXRlWzMyXQoJZnJhbWVfZGlnIDcgLy8gaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveE9mZnNldDogdWludDY0CglmcmFtZV9kaWcgNSAvLyBjb21wdXRlZENoYWxsZW5nZTogYnl0ZVtdCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy9tYWhiZXIuYWxnby50czo0MTgKCS8vIHJldHVybiBbaW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveElkLCBpbnRlcm1lZGlhdGVDaGFsbGVuZ2VzQm94T2Zmc2V0XTsKCWZyYW1lX2RpZyA4IC8vIGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hJZDogYnl0ZVszMl0KCWZyYW1lX2RpZyA3IC8vIGludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3hPZmZzZXQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gOAoJcmV0c3ViCgpjcmVhdGVfTm9PcDoKCW1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCBhYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCWVycgoKY2FsbF9Ob09wOgoJbWV0aG9kICJkdW1teU9wVXAodWludDY0KXVpbnQ2NCIKCW1ldGhvZCAicHVibGljU2NhbGFyTXVsdEJhc2UoYnl0ZVtdKWJ5dGVbXSIKCW1ldGhvZCAicHVibGljU2NhbGFyTXVsdChieXRlW10sYnl0ZVtdKWJ5dGVbXSIKCW1ldGhvZCAicHVibGljVmFsaWRQb2ludChieXRlW10pYm9vbCIKCW1ldGhvZCAicHVibGljUG9pbnRBZGQoYnl0ZVtdLGJ5dGVbXSlieXRlW10iCgltZXRob2QgInB1YmxpY0hhc2hQb2ludFRvUG9pbnQoYnl0ZVtdKWJ5dGVbXSIKCW1ldGhvZCAicHVibGljQ2hhbGxlbmdlKGJ5dGVbXSxieXRlW10sYnl0ZVtdLGJ5dGVbXSxieXRlW10pYnl0ZVtdIgoJbWV0aG9kICJwdWJsaWNDaGFsbGVuZ2VMc2lnKGJ5dGVbXSxieXRlW10sYnl0ZVtdLGJ5dGVbXSxieXRlW10scGF5KWJ5dGVbXSIKCW1ldGhvZCAiZGVwb3NpdChwYXksYnl0ZVtdKXVpbnQ2NFtdIgoJbWV0aG9kICJpbml0V2l0aGRyYXdhbFNlc3Npb24ocGF5LGJ5dGVbXSxieXRlW10pYnl0ZVszMl0iCgltZXRob2QgImNyZWF0ZVVwbG9hZFByZWNvbXB1dGVkQ2hhbGxlbmdlc0JveChwYXksYnl0ZVtdLHVpbnQ2NCx1aW50NjQpYnl0ZVszMl0iCgltZXRob2QgInVwbG9hZFByZWNvbXB1dGVkQ2hhbGxlbmdlcyhieXRlW10sdWludDY0LGJ5dGVbXSlieXRlWzMyXSIKCW1ldGhvZCAiY3JlYXRlSW50ZXJtZWRpYXRlQ2hhbGxlbmdlc0JveChwYXksYnl0ZVtdLHVpbnQ2NCx1aW50NjQpYnl0ZVszMl0iCgltZXRob2QgImNvbXB1dGVJbmRpdmlkdWFsQ2hhbGxlbmdlKGJ5dGVbXSxieXRlW10sdWludDY0LGJ5dGVbXSx1aW50NjQsdWludDY0KShieXRlWzMyXSx1aW50NjQpIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggYWJpX3JvdXRlX2R1bW15T3BVcCBhYmlfcm91dGVfcHVibGljU2NhbGFyTXVsdEJhc2UgYWJpX3JvdXRlX3B1YmxpY1NjYWxhck11bHQgYWJpX3JvdXRlX3B1YmxpY1ZhbGlkUG9pbnQgYWJpX3JvdXRlX3B1YmxpY1BvaW50QWRkIGFiaV9yb3V0ZV9wdWJsaWNIYXNoUG9pbnRUb1BvaW50IGFiaV9yb3V0ZV9wdWJsaWNDaGFsbGVuZ2UgYWJpX3JvdXRlX3B1YmxpY0NoYWxsZW5nZUxzaWcgYWJpX3JvdXRlX2RlcG9zaXQgYWJpX3JvdXRlX2luaXRXaXRoZHJhd2FsU2Vzc2lvbiBhYmlfcm91dGVfY3JlYXRlVXBsb2FkUHJlY29tcHV0ZWRDaGFsbGVuZ2VzQm94IGFiaV9yb3V0ZV91cGxvYWRQcmVjb21wdXRlZENoYWxsZW5nZXMgYWJpX3JvdXRlX2NyZWF0ZUludGVybWVkaWF0ZUNoYWxsZW5nZXNCb3ggYWJpX3JvdXRlX2NvbXB1dGVJbmRpdmlkdWFsQ2hhbGxlbmdlCgllcnI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "Mahber",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "dummyOpUp",
        "desc": "Dummy Op UpDummy operation to get more opcode budget@i- The number to return, necssary to deduplicate the name",
        "args": [
          {
            "name": "i",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "the number (but we do nothing with it)"
        }
      },
      {
        "name": "publicScalarMultBase",
        "desc": "publicScalarMultBasePublic wrapper around the scalarMultBase method, allowing it to be tested directly.@scalar- The scalar to multiply the basepoint by.",
        "args": [
          {
            "name": "scalar",
            "type": "byte[]"
          }
        ],
        "returns": {
          "type": "byte[]",
          "desc": "the content of the scalarMultBase call"
        }
      },
      {
        "name": "publicScalarMult",
        "desc": "publicScalarMultPublic wrapper around the scalarMult method, allowing it to be tested directly.@scalar- The scalar to multiply the point with@point- The point that is multiplied with the scalar",
        "args": [
          {
            "name": "scalar",
            "type": "byte[]"
          },
          {
            "name": "point",
            "type": "byte[]"
          }
        ],
        "returns": {
          "type": "byte[]",
          "desc": "the content of the scalarMult call"
        }
      },
      {
        "name": "publicValidPoint",
        "desc": "publicValidPointPublic wrapper around the validPoint method, allowing it to be tested directly.@point- The point to check",
        "args": [
          {
            "name": "point",
            "type": "byte[]"
          }
        ],
        "returns": {
          "type": "bool",
          "desc": "the content of the validPoint call"
        }
      },
      {
        "name": "publicPointAdd",
        "desc": "publicPointAddPublic wrapper around the pointAdd method, allowing it to be tested directly.",
        "args": [
          {
            "name": "pointA",
            "type": "byte[]",
            "desc": "The first point"
          },
          {
            "name": "pointB",
            "type": "byte[]",
            "desc": "The second point"
          }
        ],
        "returns": {
          "type": "byte[]",
          "desc": "the content of the pointAdd call"
        }
      },
      {
        "name": "publicHashPointToPoint",
        "desc": "publicHashPointToPointPublic wrapper around the hashPointToPoint method, allowing it to be tested directly.",
        "args": [
          {
            "name": "point",
            "type": "byte[]",
            "desc": "The point to hash"
          }
        ],
        "returns": {
          "type": "byte[]",
          "desc": "the content of the hashPointToPoint call"
        }
      },
      {
        "name": "publicChallenge",
        "desc": "publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.",
        "args": [
          {
            "name": "msg",
            "type": "byte[]",
            "desc": "The message to be signed"
          },
          {
            "name": "nonce",
            "type": "byte[]",
            "desc": "The nonce, part of the ring signature itself, aka one of the fake secret keys"
          },
          {
            "name": "cPrev",
            "type": "byte[]",
            "desc": "The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)"
          },
          {
            "name": "pk",
            "type": "byte[]",
            "desc": "The specific public key in the ring (indexed from the array of public keys)"
          },
          {
            "name": "keyImage",
            "type": "byte[]",
            "desc": "The key image of the signer, required for linkabiltiy to prevent double spending"
          }
        ],
        "returns": {
          "type": "byte[]",
          "desc": "- the content of the privateChallenge call"
        }
      },
      {
        "name": "publicChallengeLsig",
        "desc": "publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.",
        "args": [
          {
            "name": "msg",
            "type": "byte[]",
            "desc": "The message to be signed"
          },
          {
            "name": "nonce",
            "type": "byte[]",
            "desc": "The nonce, part of the ring signature itself, aka one of the fake secret keys"
          },
          {
            "name": "cPrev",
            "type": "byte[]",
            "desc": "The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)"
          },
          {
            "name": "pk",
            "type": "byte[]",
            "desc": "The specific public key in the ring (indexed from the array of public keys)"
          },
          {
            "name": "keyImage",
            "type": "byte[]",
            "desc": "The key image of the signer, required for linkabiltiy to prevent double spending"
          },
          {
            "name": "lsigTxn",
            "type": "pay"
          }
        ],
        "returns": {
          "type": "byte[]",
          "desc": "- the content of the privateChallenge call"
        }
      },
      {
        "name": "deposit",
        "desc": "depositDeposit funds + public key into the contract",
        "args": [
          {
            "name": "depositTxn",
            "type": "pay"
          },
          {
            "name": "pk",
            "type": "byte[]",
            "desc": "The public key to depositTODO: Add custom EdDSA to check that the depositor knows the secret key. Useful to prevent rogue key attack, adding the negative of another pk."
          }
        ],
        "returns": {
          "type": "uint64[]",
          "desc": "- the number id of the public key, if successful. fails if unsuccessful."
        }
      },
      {
        "name": "initWithdrawalSession",
        "desc": "initWithdrawalCreates a box representing a \"withdrawal session\".Of key importance is the signed message string, which must contain the following:Ring Size - Chosen number of PKs, i.e. size of anonymity setKey Image - The keyimage, the one thing that is unique for a withdrawalApp Id - The id of the smart contract appNominal amount - The denomination of the contract, what was deposited originallyASA ID - Clarifies the ASA ID. (Plain Algo has ID 0, \"the default\" asset of Algorand)Withdrawal Address - Address of the final recipient of the fundsRelayer Address - Address of the relayer, facilitating the withdrawal (could be same as withdrawal address)Relayer Fee - The fee the relayer charges for facilitating the withdrawal (could be 0)The hash of the message becomes the id of the withdrawal session's box.",
        "args": [
          {
            "name": "mbbrDepositTxn",
            "type": "pay",
            "desc": "The transaction that deposited the MBBR"
          },
          {
            "name": "msg",
            "type": "byte[]",
            "desc": "Signed message"
          },
          {
            "name": "initialChallenge",
            "type": "byte[]",
            "desc": "The initial challenge, which needs to be re-created to verify the ring signature"
          }
        ],
        "returns": {
          "type": "byte[32]",
          "desc": "- the id of the withdrawal session box"
        }
      },
      {
        "name": "createUploadPrecomputedChallengesBox",
        "desc": "TODO: destroyWithdrawalSession, IF SESSION LOCKED",
        "args": [
          {
            "name": "mbbrDepositTxn",
            "type": "pay"
          },
          {
            "name": "msg",
            "type": "byte[]"
          },
          {
            "name": "boxIndex",
            "type": "uint64"
          },
          {
            "name": "boxSize",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "byte[32]"
        }
      },
      {
        "name": "uploadPrecomputedChallenges",
        "desc": "uploadPrecomputedChallengesCreates a box and uploads the precomputed challenges into it.",
        "args": [
          {
            "name": "msg",
            "type": "byte[]",
            "desc": "Msg, functioning as the id for the withdrawal session"
          },
          {
            "name": "boxIndex",
            "type": "uint64"
          },
          {
            "name": "precomputedChallenges",
            "type": "byte[]"
          }
        ],
        "returns": {
          "type": "byte[32]"
        }
      },
      {
        "name": "createIntermediateChallengesBox",
        "desc": "createIntermediateChallengesBoxCreates a box that will be used to contain intermediateChallengesBox.Should eventually be a mirror image of the corresponding uploadPrecomputedChallengesBox.",
        "args": [
          {
            "name": "mbbrDepositTxn",
            "type": "pay"
          },
          {
            "name": "msg",
            "type": "byte[]",
            "desc": "Msg, functioning as the id for the withdrawal session"
          },
          {
            "name": "boxIndex",
            "type": "uint64",
            "desc": "The index of the precomputed challenge box, incrementing with each chunk of date."
          },
          {
            "name": "boxSize",
            "type": "uint64",
            "desc": "The size of the precomputed challenge box"
          }
        ],
        "returns": {
          "type": "byte[32]",
          "desc": "- the id of the precomputed challenge box"
        }
      },
      {
        "name": "computeIndividualChallenge",
        "desc": "computeIndividualChallengeComputes an individual challenge.Note that the previous challenge is loaded specifically from the precomputed challenges box.While the calculated challenge is loaded into the intermediate challenges box.At the end we will compare if the two boxes are the same, and of course that the last challenge is the same as the initial challenge.By loading specifically from the precomputed challenges box we can verify in parallell.The odds of being able to arrive at the same initial challenge in the last challenge is astronomically low UNLESS it is a valid ring signature.Public keys are of course loaded from the contract storage.",
        "args": [
          {
            "name": "msg",
            "type": "byte[]",
            "desc": "The message to be signed"
          },
          {
            "name": "nonce",
            "type": "byte[]",
            "desc": "The nonce, part of the ring signature itself, aka one of the fake secret keys"
          },
          {
            "name": "pkIndex",
            "type": "uint64",
            "desc": "The index number of the public key in the smart contract storage"
          },
          {
            "name": "keyImage",
            "type": "byte[]",
            "desc": "The key image of the signer, required for linkabiltiy to prevent double spending"
          },
          {
            "name": "cPrevBoxIndex",
            "type": "uint64"
          },
          {
            "name": "cPrevOffset",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(byte[32],uint64)"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt 
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

/**
 * Defines the types of available calls and state of the Mahber smart contract.
 */
export type Mahber = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'dummyOpUp(uint64)uint64' | 'dummyOpUp', {
      argsObj: {
        i: bigint | number
      }
      argsTuple: [i: bigint | number]
      /**
       * the number (but we do nothing with it)
       */
      returns: bigint
    }>
    & Record<'publicScalarMultBase(byte[])byte[]' | 'publicScalarMultBase', {
      argsObj: {
        scalar: Uint8Array
      }
      argsTuple: [scalar: Uint8Array]
      /**
       * the content of the scalarMultBase call
       */
      returns: Uint8Array
    }>
    & Record<'publicScalarMult(byte[],byte[])byte[]' | 'publicScalarMult', {
      argsObj: {
        scalar: Uint8Array
        point: Uint8Array
      }
      argsTuple: [scalar: Uint8Array, point: Uint8Array]
      /**
       * the content of the scalarMult call
       */
      returns: Uint8Array
    }>
    & Record<'publicValidPoint(byte[])bool' | 'publicValidPoint', {
      argsObj: {
        point: Uint8Array
      }
      argsTuple: [point: Uint8Array]
      /**
       * the content of the validPoint call
       */
      returns: boolean
    }>
    & Record<'publicPointAdd(byte[],byte[])byte[]' | 'publicPointAdd', {
      argsObj: {
        /**
         * The first point
         */
        pointA: Uint8Array
        /**
         * The second point
         */
        pointB: Uint8Array
      }
      argsTuple: [pointA: Uint8Array, pointB: Uint8Array]
      /**
       * the content of the pointAdd call
       */
      returns: Uint8Array
    }>
    & Record<'publicHashPointToPoint(byte[])byte[]' | 'publicHashPointToPoint', {
      argsObj: {
        /**
         * The point to hash
         */
        point: Uint8Array
      }
      argsTuple: [point: Uint8Array]
      /**
       * the content of the hashPointToPoint call
       */
      returns: Uint8Array
    }>
    & Record<'publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]' | 'publicChallenge', {
      argsObj: {
        /**
         * The message to be signed
         */
        msg: Uint8Array
        /**
         * The nonce, part of the ring signature itself, aka one of the fake secret keys
         */
        nonce: Uint8Array
        /**
         * The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)
         */
        cPrev: Uint8Array
        /**
         * The specific public key in the ring (indexed from the array of public keys)
         */
        pk: Uint8Array
        /**
         * The key image of the signer, required for linkabiltiy to prevent double spending
         */
        keyImage: Uint8Array
      }
      argsTuple: [msg: Uint8Array, nonce: Uint8Array, cPrev: Uint8Array, pk: Uint8Array, keyImage: Uint8Array]
      /**
       * - the content of the privateChallenge call
       */
      returns: Uint8Array
    }>
    & Record<'publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[]' | 'publicChallengeLsig', {
      argsObj: {
        /**
         * The message to be signed
         */
        msg: Uint8Array
        /**
         * The nonce, part of the ring signature itself, aka one of the fake secret keys
         */
        nonce: Uint8Array
        /**
         * The previous challenge, or the base challenge if this is the first link (in which case it is part of the ring sig)
         */
        cPrev: Uint8Array
        /**
         * The specific public key in the ring (indexed from the array of public keys)
         */
        pk: Uint8Array
        /**
         * The key image of the signer, required for linkabiltiy to prevent double spending
         */
        keyImage: Uint8Array
        lsigTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [msg: Uint8Array, nonce: Uint8Array, cPrev: Uint8Array, pk: Uint8Array, keyImage: Uint8Array, lsigTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      /**
       * - the content of the privateChallenge call
       */
      returns: Uint8Array
    }>
    & Record<'deposit(pay,byte[])uint64[]' | 'deposit', {
      argsObj: {
        depositTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * The public key to depositTODO: Add custom EdDSA to check that the depositor knows the secret key. Useful to prevent rogue key attack, adding the negative of another pk.
         */
        pk: Uint8Array
      }
      argsTuple: [depositTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>, pk: Uint8Array]
      /**
       * - the number id of the public key, if successful. fails if unsuccessful.
       */
      returns: bigint[]
    }>
    & Record<'initWithdrawalSession(pay,byte[],byte[])byte[32]' | 'initWithdrawalSession', {
      argsObj: {
        /**
         * The transaction that deposited the MBBR
         */
        mbbrDepositTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Signed message
         */
        msg: Uint8Array
        /**
         * The initial challenge, which needs to be re-created to verify the ring signature
         */
        initialChallenge: Uint8Array
      }
      argsTuple: [mbbrDepositTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>, msg: Uint8Array, initialChallenge: Uint8Array]
      /**
       * - the id of the withdrawal session box
       */
      returns: Uint8Array
    }>
    & Record<'createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]' | 'createUploadPrecomputedChallengesBox', {
      argsObj: {
        mbbrDepositTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
        msg: Uint8Array
        boxIndex: bigint | number
        boxSize: bigint | number
      }
      argsTuple: [mbbrDepositTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>, msg: Uint8Array, boxIndex: bigint | number, boxSize: bigint | number]
      returns: Uint8Array
    }>
    & Record<'uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]' | 'uploadPrecomputedChallenges', {
      argsObj: {
        /**
         * Msg, functioning as the id for the withdrawal session
         */
        msg: Uint8Array
        boxIndex: bigint | number
        precomputedChallenges: Uint8Array
      }
      argsTuple: [msg: Uint8Array, boxIndex: bigint | number, precomputedChallenges: Uint8Array]
      returns: Uint8Array
    }>
    & Record<'createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]' | 'createIntermediateChallengesBox', {
      argsObj: {
        mbbrDepositTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Msg, functioning as the id for the withdrawal session
         */
        msg: Uint8Array
        /**
         * The index of the precomputed challenge box, incrementing with each chunk of date.
         */
        boxIndex: bigint | number
        /**
         * The size of the precomputed challenge box
         */
        boxSize: bigint | number
      }
      argsTuple: [mbbrDepositTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>, msg: Uint8Array, boxIndex: bigint | number, boxSize: bigint | number]
      /**
       * - the id of the precomputed challenge box
       */
      returns: Uint8Array
    }>
    & Record<'computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)' | 'computeIndividualChallenge', {
      argsObj: {
        /**
         * The message to be signed
         */
        msg: Uint8Array
        /**
         * The nonce, part of the ring signature itself, aka one of the fake secret keys
         */
        nonce: Uint8Array
        /**
         * The index number of the public key in the smart contract storage
         */
        pkIndex: bigint | number
        /**
         * The key image of the signer, required for linkabiltiy to prevent double spending
         */
        keyImage: Uint8Array
        cPrevBoxIndex: bigint | number
        cPrevOffset: bigint | number
      }
      argsTuple: [msg: Uint8Array, nonce: Uint8Array, pkIndex: bigint | number, keyImage: Uint8Array, cPrevBoxIndex: bigint | number, cPrevOffset: bigint | number]
      returns: [Uint8Array, bigint]
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'denomination'?: IntegerState
      'asaId'?: IntegerState
      'pkIndex'?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type MahberSig = keyof Mahber['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends MahberSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the Mahber smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends MahberSig> = Mahber['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the Mahber smart contract to the method's return type
 */
export type MethodReturn<TSignature extends MahberSig> = Mahber['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type MahberCreateCalls = (typeof MahberCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type MahberCreateCallParams =
  | (TypedCallParams<'createApplication()void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type MahberDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: MahberCreateCalls) => MahberCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class MahberCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the Mahber smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the dummyOpUp(uint64)uint64 ABI method
   *
   * Dummy Op UpDummy operation to get more opcode budget@i- The number to return, necssary to deduplicate the name
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static dummyOpUp(args: MethodArgs<'dummyOpUp(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'dummyOpUp(uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.i],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the publicScalarMultBase(byte[])byte[] ABI method
   *
   * publicScalarMultBasePublic wrapper around the scalarMultBase method, allowing it to be tested directly.@scalar- The scalar to multiply the basepoint by.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static publicScalarMultBase(args: MethodArgs<'publicScalarMultBase(byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'publicScalarMultBase(byte[])byte[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.scalar],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the publicScalarMult(byte[],byte[])byte[] ABI method
   *
   * publicScalarMultPublic wrapper around the scalarMult method, allowing it to be tested directly.@scalar- The scalar to multiply the point with@point- The point that is multiplied with the scalar
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static publicScalarMult(args: MethodArgs<'publicScalarMult(byte[],byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'publicScalarMult(byte[],byte[])byte[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.scalar, args.point],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the publicValidPoint(byte[])bool ABI method
   *
   * publicValidPointPublic wrapper around the validPoint method, allowing it to be tested directly.@point- The point to check
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static publicValidPoint(args: MethodArgs<'publicValidPoint(byte[])bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'publicValidPoint(byte[])bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.point],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the publicPointAdd(byte[],byte[])byte[] ABI method
   *
   * publicPointAddPublic wrapper around the pointAdd method, allowing it to be tested directly.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static publicPointAdd(args: MethodArgs<'publicPointAdd(byte[],byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'publicPointAdd(byte[],byte[])byte[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.pointA, args.pointB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the publicHashPointToPoint(byte[])byte[] ABI method
   *
   * publicHashPointToPointPublic wrapper around the hashPointToPoint method, allowing it to be tested directly.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static publicHashPointToPoint(args: MethodArgs<'publicHashPointToPoint(byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'publicHashPointToPoint(byte[])byte[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.point],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[] ABI method
   *
   * publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static publicChallenge(args: MethodArgs<'publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.msg, args.nonce, args.cPrev, args.pk, args.keyImage],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[] ABI method
   *
   * publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static publicChallengeLsig(args: MethodArgs<'publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.msg, args.nonce, args.cPrev, args.pk, args.keyImage, args.lsigTxn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the deposit(pay,byte[])uint64[] ABI method
   *
   * depositDeposit funds + public key into the contract
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static deposit(args: MethodArgs<'deposit(pay,byte[])uint64[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'deposit(pay,byte[])uint64[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.depositTxn, args.pk],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the initWithdrawalSession(pay,byte[],byte[])byte[32] ABI method
   *
   * initWithdrawalCreates a box representing a "withdrawal session".Of key importance is the signed message string, which must contain the following:Ring Size - Chosen number of PKs, i.e. size of anonymity setKey Image - The keyimage, the one thing that is unique for a withdrawalApp Id - The id of the smart contract appNominal amount - The denomination of the contract, what was deposited originallyASA ID - Clarifies the ASA ID. (Plain Algo has ID 0, "the default" asset of Algorand)Withdrawal Address - Address of the final recipient of the fundsRelayer Address - Address of the relayer, facilitating the withdrawal (could be same as withdrawal address)Relayer Fee - The fee the relayer charges for facilitating the withdrawal (could be 0)The hash of the message becomes the id of the withdrawal session's box.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static initWithdrawalSession(args: MethodArgs<'initWithdrawalSession(pay,byte[],byte[])byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'initWithdrawalSession(pay,byte[],byte[])byte[32]' as const,
      methodArgs: Array.isArray(args) ? args : [args.mbbrDepositTxn, args.msg, args.initialChallenge],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32] ABI method
   *
   * TODO: destroyWithdrawalSession, IF SESSION LOCKED
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static createUploadPrecomputedChallengesBox(args: MethodArgs<'createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]' as const,
      methodArgs: Array.isArray(args) ? args : [args.mbbrDepositTxn, args.msg, args.boxIndex, args.boxSize],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32] ABI method
   *
   * uploadPrecomputedChallengesCreates a box and uploads the precomputed challenges into it.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static uploadPrecomputedChallenges(args: MethodArgs<'uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]' as const,
      methodArgs: Array.isArray(args) ? args : [args.msg, args.boxIndex, args.precomputedChallenges],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32] ABI method
   *
   * createIntermediateChallengesBoxCreates a box that will be used to contain intermediateChallengesBox.Should eventually be a mirror image of the corresponding uploadPrecomputedChallengesBox.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static createIntermediateChallengesBox(args: MethodArgs<'createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]' as const,
      methodArgs: Array.isArray(args) ? args : [args.mbbrDepositTxn, args.msg, args.boxIndex, args.boxSize],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64) ABI method
   *
   * computeIndividualChallengeComputes an individual challenge.Note that the previous challenge is loaded specifically from the precomputed challenges box.While the calculated challenge is loaded into the intermediate challenges box.At the end we will compare if the two boxes are the same, and of course that the last challenge is the same as the initial challenge.By loading specifically from the precomputed challenges box we can verify in parallell.The odds of being able to arrive at the same initial challenge in the last challenge is astronomically low UNLESS it is a valid ring signature.Public keys are of course loaded from the contract storage.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static computeIndividualChallenge(args: MethodArgs<'computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.msg, args.nonce, args.pkIndex, args.keyImage, args.cPrevBoxIndex, args.cPrevOffset],
      ...params,
    }
  }
}

/**
 * A client to make calls to the Mahber smart contract
 */
export class MahberClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `MahberClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue }
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof Mahber['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the Mahber smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: MahberDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(MahberCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the Mahber smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'createApplication()void'>>> {
        return $this.mapReturnValue(await $this.appClient.create(MahberCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the Mahber smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the dummyOpUp(uint64)uint64 ABI method.
   *
   * Dummy Op UpDummy operation to get more opcode budget@i- The number to return, necssary to deduplicate the name
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the number (but we do nothing with it)
   */
  public dummyOpUp(args: MethodArgs<'dummyOpUp(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.dummyOpUp(args, params))
  }

  /**
   * Calls the publicScalarMultBase(byte[])byte[] ABI method.
   *
   * publicScalarMultBasePublic wrapper around the scalarMultBase method, allowing it to be tested directly.@scalar- The scalar to multiply the basepoint by.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the content of the scalarMultBase call
   */
  public publicScalarMultBase(args: MethodArgs<'publicScalarMultBase(byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.publicScalarMultBase(args, params))
  }

  /**
   * Calls the publicScalarMult(byte[],byte[])byte[] ABI method.
   *
   * publicScalarMultPublic wrapper around the scalarMult method, allowing it to be tested directly.@scalar- The scalar to multiply the point with@point- The point that is multiplied with the scalar
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the content of the scalarMult call
   */
  public publicScalarMult(args: MethodArgs<'publicScalarMult(byte[],byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.publicScalarMult(args, params))
  }

  /**
   * Calls the publicValidPoint(byte[])bool ABI method.
   *
   * publicValidPointPublic wrapper around the validPoint method, allowing it to be tested directly.@point- The point to check
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the content of the validPoint call
   */
  public publicValidPoint(args: MethodArgs<'publicValidPoint(byte[])bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.publicValidPoint(args, params))
  }

  /**
   * Calls the publicPointAdd(byte[],byte[])byte[] ABI method.
   *
   * publicPointAddPublic wrapper around the pointAdd method, allowing it to be tested directly.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the content of the pointAdd call
   */
  public publicPointAdd(args: MethodArgs<'publicPointAdd(byte[],byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.publicPointAdd(args, params))
  }

  /**
   * Calls the publicHashPointToPoint(byte[])byte[] ABI method.
   *
   * publicHashPointToPointPublic wrapper around the hashPointToPoint method, allowing it to be tested directly.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the content of the hashPointToPoint call
   */
  public publicHashPointToPoint(args: MethodArgs<'publicHashPointToPoint(byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.publicHashPointToPoint(args, params))
  }

  /**
   * Calls the publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[] ABI method.
   *
   * publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: - the content of the privateChallenge call
   */
  public publicChallenge(args: MethodArgs<'publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.publicChallenge(args, params))
  }

  /**
   * Calls the publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[] ABI method.
   *
   * publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: - the content of the privateChallenge call
   */
  public publicChallengeLsig(args: MethodArgs<'publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.publicChallengeLsig(args, params))
  }

  /**
   * Calls the deposit(pay,byte[])uint64[] ABI method.
   *
   * depositDeposit funds + public key into the contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: - the number id of the public key, if successful. fails if unsuccessful.
   */
  public deposit(args: MethodArgs<'deposit(pay,byte[])uint64[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.deposit(args, params))
  }

  /**
   * Calls the initWithdrawalSession(pay,byte[],byte[])byte[32] ABI method.
   *
   * initWithdrawalCreates a box representing a "withdrawal session".Of key importance is the signed message string, which must contain the following:Ring Size - Chosen number of PKs, i.e. size of anonymity setKey Image - The keyimage, the one thing that is unique for a withdrawalApp Id - The id of the smart contract appNominal amount - The denomination of the contract, what was deposited originallyASA ID - Clarifies the ASA ID. (Plain Algo has ID 0, "the default" asset of Algorand)Withdrawal Address - Address of the final recipient of the fundsRelayer Address - Address of the relayer, facilitating the withdrawal (could be same as withdrawal address)Relayer Fee - The fee the relayer charges for facilitating the withdrawal (could be 0)The hash of the message becomes the id of the withdrawal session's box.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: - the id of the withdrawal session box
   */
  public initWithdrawalSession(args: MethodArgs<'initWithdrawalSession(pay,byte[],byte[])byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.initWithdrawalSession(args, params))
  }

  /**
   * Calls the createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32] ABI method.
   *
   * TODO: destroyWithdrawalSession, IF SESSION LOCKED
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public createUploadPrecomputedChallengesBox(args: MethodArgs<'createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.createUploadPrecomputedChallengesBox(args, params))
  }

  /**
   * Calls the uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32] ABI method.
   *
   * uploadPrecomputedChallengesCreates a box and uploads the precomputed challenges into it.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public uploadPrecomputedChallenges(args: MethodArgs<'uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.uploadPrecomputedChallenges(args, params))
  }

  /**
   * Calls the createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32] ABI method.
   *
   * createIntermediateChallengesBoxCreates a box that will be used to contain intermediateChallengesBox.Should eventually be a mirror image of the corresponding uploadPrecomputedChallengesBox.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: - the id of the precomputed challenge box
   */
  public createIntermediateChallengesBox(args: MethodArgs<'createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.createIntermediateChallengesBox(args, params))
  }

  /**
   * Calls the computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64) ABI method.
   *
   * computeIndividualChallengeComputes an individual challenge.Note that the previous challenge is loaded specifically from the precomputed challenges box.While the calculated challenge is loaded into the intermediate challenges box.At the end we will compare if the two boxes are the same, and of course that the last challenge is the same as the initial challenge.By loading specifically from the precomputed challenges box we can verify in parallell.The odds of being able to arrive at the same initial challenge in the last challenge is astronomically low UNLESS it is a valid ring signature.Public keys are of course loaded from the contract storage.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public computeIndividualChallenge(args: MethodArgs<'computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MahberCallFactory.computeIndividualChallenge(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<Mahber['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get denomination() {
        return MahberClient.getIntegerState(state, 'denomination')
      },
      get asaId() {
        return MahberClient.getIntegerState(state, 'asaId')
      },
      get pkIndex() {
        return MahberClient.getIntegerState(state, 'pkIndex')
      },
    }
  }

  public compose(): MahberComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      dummyOpUp(args: MethodArgs<'dummyOpUp(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.dummyOpUp(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      publicScalarMultBase(args: MethodArgs<'publicScalarMultBase(byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.publicScalarMultBase(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      publicScalarMult(args: MethodArgs<'publicScalarMult(byte[],byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.publicScalarMult(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      publicValidPoint(args: MethodArgs<'publicValidPoint(byte[])bool'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.publicValidPoint(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      publicPointAdd(args: MethodArgs<'publicPointAdd(byte[],byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.publicPointAdd(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      publicHashPointToPoint(args: MethodArgs<'publicHashPointToPoint(byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.publicHashPointToPoint(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      publicChallenge(args: MethodArgs<'publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.publicChallenge(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      publicChallengeLsig(args: MethodArgs<'publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.publicChallengeLsig(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      deposit(args: MethodArgs<'deposit(pay,byte[])uint64[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.deposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      initWithdrawalSession(args: MethodArgs<'initWithdrawalSession(pay,byte[],byte[])byte[32]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.initWithdrawalSession(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      createUploadPrecomputedChallengesBox(args: MethodArgs<'createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.createUploadPrecomputedChallengesBox(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      uploadPrecomputedChallenges(args: MethodArgs<'uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.uploadPrecomputedChallenges(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      createIntermediateChallengesBox(args: MethodArgs<'createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.createIntermediateChallengesBox(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      computeIndividualChallenge(args: MethodArgs<'computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.computeIndividualChallenge(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async execute() {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as MahberComposer
  }
}
export type MahberComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the dummyOpUp(uint64)uint64 ABI method.
   *
   * Dummy Op UpDummy operation to get more opcode budget@i- The number to return, necssary to deduplicate the name
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  dummyOpUp(args: MethodArgs<'dummyOpUp(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'dummyOpUp(uint64)uint64'>]>

  /**
   * Calls the publicScalarMultBase(byte[])byte[] ABI method.
   *
   * publicScalarMultBasePublic wrapper around the scalarMultBase method, allowing it to be tested directly.@scalar- The scalar to multiply the basepoint by.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  publicScalarMultBase(args: MethodArgs<'publicScalarMultBase(byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'publicScalarMultBase(byte[])byte[]'>]>

  /**
   * Calls the publicScalarMult(byte[],byte[])byte[] ABI method.
   *
   * publicScalarMultPublic wrapper around the scalarMult method, allowing it to be tested directly.@scalar- The scalar to multiply the point with@point- The point that is multiplied with the scalar
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  publicScalarMult(args: MethodArgs<'publicScalarMult(byte[],byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'publicScalarMult(byte[],byte[])byte[]'>]>

  /**
   * Calls the publicValidPoint(byte[])bool ABI method.
   *
   * publicValidPointPublic wrapper around the validPoint method, allowing it to be tested directly.@point- The point to check
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  publicValidPoint(args: MethodArgs<'publicValidPoint(byte[])bool'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'publicValidPoint(byte[])bool'>]>

  /**
   * Calls the publicPointAdd(byte[],byte[])byte[] ABI method.
   *
   * publicPointAddPublic wrapper around the pointAdd method, allowing it to be tested directly.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  publicPointAdd(args: MethodArgs<'publicPointAdd(byte[],byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'publicPointAdd(byte[],byte[])byte[]'>]>

  /**
   * Calls the publicHashPointToPoint(byte[])byte[] ABI method.
   *
   * publicHashPointToPointPublic wrapper around the hashPointToPoint method, allowing it to be tested directly.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  publicHashPointToPoint(args: MethodArgs<'publicHashPointToPoint(byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'publicHashPointToPoint(byte[])byte[]'>]>

  /**
   * Calls the publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[] ABI method.
   *
   * publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  publicChallenge(args: MethodArgs<'publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'publicChallenge(byte[],byte[],byte[],byte[],byte[])byte[]'>]>

  /**
   * Calls the publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[] ABI method.
   *
   * publicChallengePublic wrapper around the challenge method, allowing it to be tested directly.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  publicChallengeLsig(args: MethodArgs<'publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'publicChallengeLsig(byte[],byte[],byte[],byte[],byte[],pay)byte[]'>]>

  /**
   * Calls the deposit(pay,byte[])uint64[] ABI method.
   *
   * depositDeposit funds + public key into the contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  deposit(args: MethodArgs<'deposit(pay,byte[])uint64[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'deposit(pay,byte[])uint64[]'>]>

  /**
   * Calls the initWithdrawalSession(pay,byte[],byte[])byte[32] ABI method.
   *
   * initWithdrawalCreates a box representing a "withdrawal session".Of key importance is the signed message string, which must contain the following:Ring Size - Chosen number of PKs, i.e. size of anonymity setKey Image - The keyimage, the one thing that is unique for a withdrawalApp Id - The id of the smart contract appNominal amount - The denomination of the contract, what was deposited originallyASA ID - Clarifies the ASA ID. (Plain Algo has ID 0, "the default" asset of Algorand)Withdrawal Address - Address of the final recipient of the fundsRelayer Address - Address of the relayer, facilitating the withdrawal (could be same as withdrawal address)Relayer Fee - The fee the relayer charges for facilitating the withdrawal (could be 0)The hash of the message becomes the id of the withdrawal session's box.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initWithdrawalSession(args: MethodArgs<'initWithdrawalSession(pay,byte[],byte[])byte[32]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'initWithdrawalSession(pay,byte[],byte[])byte[32]'>]>

  /**
   * Calls the createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32] ABI method.
   *
   * TODO: destroyWithdrawalSession, IF SESSION LOCKED
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createUploadPrecomputedChallengesBox(args: MethodArgs<'createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'createUploadPrecomputedChallengesBox(pay,byte[],uint64,uint64)byte[32]'>]>

  /**
   * Calls the uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32] ABI method.
   *
   * uploadPrecomputedChallengesCreates a box and uploads the precomputed challenges into it.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  uploadPrecomputedChallenges(args: MethodArgs<'uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'uploadPrecomputedChallenges(byte[],uint64,byte[])byte[32]'>]>

  /**
   * Calls the createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32] ABI method.
   *
   * createIntermediateChallengesBoxCreates a box that will be used to contain intermediateChallengesBox.Should eventually be a mirror image of the corresponding uploadPrecomputedChallengesBox.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createIntermediateChallengesBox(args: MethodArgs<'createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'createIntermediateChallengesBox(pay,byte[],uint64,uint64)byte[32]'>]>

  /**
   * Calls the computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64) ABI method.
   *
   * computeIndividualChallengeComputes an individual challenge.Note that the previous challenge is loaded specifically from the precomputed challenges box.While the calculated challenge is loaded into the intermediate challenges box.At the end we will compare if the two boxes are the same, and of course that the last challenge is the same as the initial challenge.By loading specifically from the precomputed challenges box we can verify in parallell.The odds of being able to arrive at the same initial challenge in the last challenge is astronomically low UNLESS it is a valid ring signature.Public keys are of course loaded from the contract storage.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  computeIndividualChallenge(args: MethodArgs<'computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, MethodReturn<'computeIndividualChallenge(byte[],byte[],uint64,byte[],uint64,uint64)(byte[32],uint64)'>]>

  /**
   * Makes a clear_state call to an existing instance of the Mahber smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): MahberComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): MahberComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Executes the transaction group and returns an array of results
   */
  execute(): Promise<MahberComposerResults<TReturns>>
}
export type MahberComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
